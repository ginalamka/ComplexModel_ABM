out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
FINAL = rbind(FINAL, out[1,])
break
}
#pop = RandomDeath(pop)                  #random mortality
tt = Migrate(pop, source, y, miggy)             #subpop migration
pop = tt[[1]]
mig = tt[[2]]  #0
sz = sz + mig #may need to edit since dead are not being removed from pop
source = tt[[3]]
if(sum(pop[,8]) <= 4){
print(paste("Population crash @ MateChoice, less than 4 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
FINAL = rbind(FINAL, out[1,])
break
}
pairs = MateChoice(pop, sex, maturity)
if(is.null(pairs)==TRUE){
print(paste("skipping pop size next, breed due to no parents"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
FINAL = rbind(FINAL, out[1,])
break  #consider whether this should be next or break
}
#REMOVED## if(sum(pairs[,1]) < 0 | sum(pairs[,2]) < 0){
#REMOVED##   print(paste("Only migrants available as parents"))
#REMOVED##   break
#REMOVED## }
pp = PopSizeNext(pop, k, r0, maturity, y, styr, endyr, nwk, dur, parameters, r, K) #ADD NEW K MODIFIER
numboff = pp[[1]]
K = pp[[2]]
if(numboff >= 1){
ttt = Breed(pop, pairs, numboff, k, sz, nSNP, nSNP.mig, broodsize, y, mu, mutate, nSNP.cons, pos1, pos2) #still needs work
pop = ttt[[1]]
bb = ttt[[2]]
sz = sz + bb
}else if(numboff <= 0){
print(paste("No new babies, skip breed"))
#next
}
pop = AgeDeath(pop, maxage, ratemort, y)                #kill indv based on age
if(sum(pop[,8]) <= 10){
print(paste("CRASH @ AgeDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2) #remember to feed to all Analyze functions!
FINAL = rbind(FINAL, out[1,])
break
}
print(paste("DONE!", y, "param", r, "rep", rr))
View(pop)
y=2
pop = AgeUp(pop)                        #age pop + 1 year
pop = FitnessDeath(pop, maturity, ratemort, y)                #kill indv
#pop = DeathByAge(pop, maxage)           #age-dependent mortality
if(sum(pop[,8]) <= 10){
print(paste("Crash @ FitnessDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
FINAL = rbind(FINAL, out[1,])
break
}
#pop = RandomDeath(pop)                  #random mortality
tt = Migrate(pop, source, y, miggy)             #subpop migration
pop = tt[[1]]
mig = tt[[2]]  #0
sz = sz + mig #may need to edit since dead are not being removed from pop
source = tt[[3]]
if(sum(pop[,8]) <= 4){
print(paste("Population crash @ MateChoice, less than 4 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
FINAL = rbind(FINAL, out[1,])
break
}
pairs = MateChoice(pop, sex, maturity)
if(is.null(pairs)==TRUE){
print(paste("skipping pop size next, breed due to no parents"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
FINAL = rbind(FINAL, out[1,])
break  #consider whether this should be next or break
}
#REMOVED## if(sum(pairs[,1]) < 0 | sum(pairs[,2]) < 0){
#REMOVED##   print(paste("Only migrants available as parents"))
#REMOVED##   break
#REMOVED## }
pp = PopSizeNext(pop, k, r0, maturity, y, styr, endyr, nwk, dur, parameters, r, K) #ADD NEW K MODIFIER
numboff = pp[[1]]
K = pp[[2]]
if(numboff >= 1){
ttt = Breed(pop, pairs, numboff, k, sz, nSNP, nSNP.mig, broodsize, y, mu, mutate, nSNP.cons, pos1, pos2) #still needs work
pop = ttt[[1]]
bb = ttt[[2]]
sz = sz + bb
}else if(numboff <= 0){
print(paste("No new babies, skip breed"))
#next
}
pop = AgeDeath(pop, maxage, ratemort, y)                #kill indv based on age
if(sum(pop[,8]) <= 10){
print(paste("CRASH @ AgeDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2) #remember to feed to all Analyze functions!
FINAL = rbind(FINAL, out[1,])
break
}
print(paste("DONE!", y, "param", r, "rep", rr))
y=3
pop = AgeUp(pop)                        #age pop + 1 year
pop = FitnessDeath(pop, maturity, ratemort, y)                #kill indv
#pop = DeathByAge(pop, maxage)           #age-dependent mortality
if(sum(pop[,8]) <= 10){
print(paste("Crash @ FitnessDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
FINAL = rbind(FINAL, out[1,])
break
}
#pop = RandomDeath(pop)                  #random mortality
tt = Migrate(pop, source, y, miggy)             #subpop migration
pop = tt[[1]]
mig = tt[[2]]  #0
sz = sz + mig #may need to edit since dead are not being removed from pop
source = tt[[3]]
if(sum(pop[,8]) <= 4){
print(paste("Population crash @ MateChoice, less than 4 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
FINAL = rbind(FINAL, out[1,])
break
}
pairs = MateChoice(pop, sex, maturity)
if(is.null(pairs)==TRUE){
print(paste("skipping pop size next, breed due to no parents"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
FINAL = rbind(FINAL, out[1,])
break  #consider whether this should be next or break
}
#REMOVED## if(sum(pairs[,1]) < 0 | sum(pairs[,2]) < 0){
#REMOVED##   print(paste("Only migrants available as parents"))
#REMOVED##   break
#REMOVED## }
pp = PopSizeNext(pop, k, r0, maturity, y, styr, endyr, nwk, dur, parameters, r, K) #ADD NEW K MODIFIER
numboff = pp[[1]]
K = pp[[2]]
if(numboff >= 1){
ttt = Breed(pop, pairs, numboff, k, sz, nSNP, nSNP.mig, broodsize, y, mu, mutate, nSNP.cons, pos1, pos2) #still needs work
pop = ttt[[1]]
bb = ttt[[2]]
sz = sz + bb
}else if(numboff <= 0){
print(paste("No new babies, skip breed"))
#next
}
pop = AgeDeath(pop, maxage, ratemort, y)                #kill indv based on age
if(sum(pop[,8]) <= 10){
print(paste("CRASH @ AgeDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2) #remember to feed to all Analyze functions!
FINAL = rbind(FINAL, out[1,])
break
}
View(pop)
#calc the total number of offspring
for(i in unique(pop_indv[,1])){                          #iterate over id
if(!is.null(nrow(pop_indv[which(pop_indv[,2] == i | pop_indv[,3] == i),, drop = FALSE]))){
temp = pop_indv[which(pop_indv[,2] == i | pop_indv[,3] == i),, drop = FALSE]           #find if id is in mom OR dad column
n = nrow(temp)
pop_indv[pop_indv[,1] == i, 6] <- n                      #put the value in the noffspring column
}else{
next
}
}
pop_indv=pop
#calc the total number of offspring
for(i in unique(pop_indv[,1])){                          #iterate over id
if(!is.null(nrow(pop_indv[which(pop_indv[,2] == i | pop_indv[,3] == i),, drop = FALSE]))){
temp = pop_indv[which(pop_indv[,2] == i | pop_indv[,3] == i),, drop = FALSE]           #find if id is in mom OR dad column
n = nrow(temp)
pop_indv[pop_indv[,1] == i, 6] <- n                      #put the value in the noffspring column
}else{
next
}
}
#calc the total number of adult offspring
for(j in unique(pop_indv[,1])){                          #iterate over id
if(!is.null(nrow(pop_indv[which((pop_indv[,2] == j | pop_indv[,3] == j) & pop_indv[,4] >= maturity),, drop=FALSE]))){
tem = pop_indv[which((pop_indv[,2] == j | pop_indv[,3] == j) & pop_indv[,4] >= maturity),, drop = FALSE]           #find if id is in mom OR dad column
m = nrow(tem)
pop_indv[pop_indv[,1] == j, 7] <- m                     #put the value in the noffspring column
}else{
next
}
}
View(pop_indv)
#calc the relative fitness - defined as repro succ of the indv/max repro succ
pop_indv[,7] <- as.numeric(pop_indv[,7])
max <- max(pop_indv[,7])
max
for(m in unique(pop_indv[,1])){
rel <- pop_indv[pop_indv[,1] == m, 7]
rel.fit <- rel/max
pop_indv[pop_indv[,1] == m, 11] <- rel.fit
}
#calc number of indv born in this generation
for(q in unique(pop_indv[,9])){       #unique generation born
temp <- pop_indv[pop_indv[,9] ==q,,drop=FALSE]
REP[(q+2),2] = nrow(temp)   #nrow(temp[,9]==q)
}
View(pop_indv)
print(paste("there are", mig, "migrants this year"))
for(m in 1:mig){
#select migrant without replacement
migrant = sample(1:nrow(source), 1, replace = F)
#take migrant from source and put into pop
pop = rbind(pop, source[migrant,])
#remove migrant from source
source = source[-migrant,]
}
#select migrant without replacement
migrant = sample(1:nrow(source), 1, replace = F)
migrant
source[migrant,]
y
source[migrant,9] <- y
source[migrant,]
#take migrant from source and put into pop
pop = rbind(pop, source[migrant,])
View(pop)
miggy=5
for(m in 1:mig){
#select migrant without replacement
migrant = sample(1:nrow(source), 1, replace = F)
source[migrant,9] <- y   #change gen born to the generation the migrant entered the pop
#take migrant from source and put into pop
pop = rbind(pop, source[migrant,])
#remove migrant from source
source = source[-migrant,]
}
View(pop)
miggy == "a"
miggy="a"
mig=5
for(m in 1:mig){
#select migrant without replacement
migrant = sample(1:nrow(source), 1, replace = F)
source[migrant,9] <- y   #change gen born to the generation the migrant entered the pop
#take migrant from source and put into pop
pop = rbind(pop, source[migrant,])
#remove migrant from source
source = source[-migrant,]
}
View(pop)
View(pop_indv)
nativ <- te[te[,2] !=-1,,drop=FALSE] #-1 is identifier for indv in Source pop
e=0
te <- pop_indv[pop_indv[,9] ==e,,drop=FALSE]
nativ <- te[te[,2] !=-1,,drop=FALSE] #-1 is identifier for indv in Source pop
nativ
View(pop_indv)
nrow(te)
nativ <- te[te[,2] !=-1,,drop=FALSE] #-1 is identifier for indv in Source pop
range(te[,2])
migr <- te[te[,2] ==-1,,drop=FALSE] #-1 is identifier for indv in Source pop
te[6,2]=-1
migr <- te[te[,2] ==-1,,drop=FALSE] #-1 is identifier for indv in Source pop
nativ <- te[te[,2] !=-1,,drop=FALSE] #-1 is identifier for indv in Source pop
View(nativ)
View(pop)
View(pop_indv)
View(pop)
View(pop_indv)
pop_indv=pop
#calc the total number of offspring
for(i in unique(pop_indv[,1])){                          #iterate over id
if(!is.null(nrow(pop_indv[which(pop_indv[,2] == i | pop_indv[,3] == i),, drop = FALSE]))){
temp = pop_indv[which(pop_indv[,2] == i | pop_indv[,3] == i),, drop = FALSE]           #find if id is in mom OR dad column
n = nrow(temp)
pop_indv[pop_indv[,1] == i, 6] <- n                      #put the value in the noffspring column
}else{
next
}
}
#calc the total number of adult offspring
for(j in unique(pop_indv[,1])){                          #iterate over id
if(!is.null(nrow(pop_indv[which((pop_indv[,2] == j | pop_indv[,3] == j) & pop_indv[,4] >= maturity),, drop=FALSE]))){
tem = pop_indv[which((pop_indv[,2] == j | pop_indv[,3] == j) & pop_indv[,4] >= maturity),, drop = FALSE]           #find if id is in mom OR dad column
m = nrow(tem)
pop_indv[pop_indv[,1] == j, 7] <- m                     #put the value in the noffspring column
}else{
next
}
}
#calc the relative fitness - defined as repro succ of the indv/max repro succ
pop_indv[,7] <- as.numeric(pop_indv[,7])
max <- max(pop_indv[,7])
for(m in unique(pop_indv[,1])){
rel <- pop_indv[pop_indv[,1] == m, 7]
rel.fit <- rel/max
pop_indv[pop_indv[,1] == m, 10] <- rel.fit   #put value in gen died column
}
REP = matrix(nrow=years+2, ncol=12) #to add source (-1) and init (0) pops
colnames(REP) = c("YearBorn", "nBornThisYear", "meanLRS", "SD", "LRSfemale", "LRSmale", "meanRRS", "SDRRS", "replicate", "parameterset", "LRSmigs", "LRSnative")
#add year to summary matrix
REP[,1] = c(-1:(nrow(REP)-2))  #-1 to years cuz the initial pop has a generation born of 0 and initial source has a gen born of -1
#calc number of indv born in this generation
for(q in unique(pop_indv[,9])){       #unique generation born
temp <- pop_indv[pop_indv[,9] ==q,,drop=FALSE]
REP[(q+2),2] = nrow(temp)   #nrow(temp[,9]==q)
}
#calc the mean LRS for this generation
for(e in unique(pop_indv[,9])){       #unique generation born
te <- pop_indv[pop_indv[,9] ==e,,drop=FALSE]
REP[(e+2),3] = mean(te[,7])   #find mean number of adult offspring
#e+1 because year 0 is included
REP[(e+2),4] = sd(te[,7])     #find standard deviation in number of adult offspring
#calc mean LRS for males and females
females <- te[te[,5]==0,,drop=FALSE] #0=female
frs = mean(females[,7])
REP[(e+2),5] = frs
males <- te[te[,5] ==1,,drop=FALSE] #1=male
mrs = mean(males[,7])
REP[(e+2),6] = mrs
migr <- te[te[,2] ==-1,,drop=FALSE] #-1 is identifier for indv in Source pop
miglrs <- mean(migr[,7])
REP[(e+2),11] = miglrs
nativ <- te[te[,2] !=-1,,drop=FALSE] #-1 is identifier for indv in Source pop
natlrs <- mean(nativ[,7])
REP[(e+2),12] = natlrs
#calc mean relative fitness
REP[(e+2),7] = mean(te[,10])  #find mean relative fitness
REP[(e+2),8] = sd(te[,10])     #find standard deviation in relative fitness
}
REP[,9] = rr #note replicate number
REP[,10] = r #note the parameter set number
View(REP)
setwd("C:/Users/ginab/Box/New Computer/Auburn/Data/ComplexModel_ABM/ABM_sep2022")
directory = getwd()
outdir = paste(directory, "/Output/", sep = "")   #  outdir = paste("C:/Users/ginab/Box/New Computer/Auburn/Data/ComplexModel_ABM", "/Output_local/", sep = "")
#set working directory, import packages, source functions,
setwd(paste(directory,"/Source/", sep = '')) #set temp working directory
library(reshape2)   #commented out 10/4/22 cuz I was getting pissed. I think this is just for plotting
library(adegenet)   #commented out 10/4/22 cuz I was getting pissed. I think this is just for plotting
library(scales) #may need this for plotting, this allows transparency in colors for overlapping lines
library(matrixStats) #need this for colCount and rowCount in ReproSuc.R
library(hierfstat)   #need this for FST analysis in Analyze.R
library(tidyr)       #need this for FST analysis in Analyze.R
library(gtools)      #commented out 10/4/22 cuz I was getting pissed. I think this is just for plotting
#library(MASS)       #used to write out dead indv - only necessary if writing out a matrix
'%NOTin%' <- Negate(`%in%`) #this defines the not in function so that I can select identities that are not defined by something (see RandomDeaths.R for an example)
#note that the ' ' is not included in the %NOTin% operator -- see https://r-lang.com/not-in-r/#:~:text=The%20not%20in%20operator%20is%20a%20logical%20vector%2C,a%20vector.%20The%20%21%20indicates%20logical%20negation%20%28NOT%29.
#source functions
source(paste(getwd(), "/RunModel.R", sep = ''))
source(paste(getwd(), "/AgeUp.R", sep = ''))
source(paste(getwd(), "/AgeDeath.R", sep = ''))
source(paste(getwd(), "/FitnessDeath.R", sep = ''))
source(paste(getwd(), "/Migrate.R", sep = ''))
source(paste(getwd(), "/MateChoice.R", sep = ''))
source(paste(getwd(), "/PopSizeNext.R", sep = ''))
source(paste(getwd(), "/Breed.R", sep = ''))
source(paste(getwd(), "/Analyze.R", sep = ''))
source(paste(getwd(), "/Plot.R", sep = ''))       #on/off switch
source(paste(getwd(), "/Plot2.R", sep = ''))       #on/off switch
source(paste(getwd(), "/RepSucc.R", sep = ''))
is.wholenumber <-
function(x, tol = .Machine$double.eps^0.5)  abs(x - round(x)) < tol
k.V           = 100
nSNP.V        = 10
miggy.V       =
"a"
LBhet.V       =
.45
maxage.V      = 9     #low ages dont work              #maximum age individuals can be; add one at first, so they will die at 4, start at -1
broodsize.V   = 2     #this is now the MAX brood size, aka max fecundity   #REMOVED##c(0:2)              #aka fecundity, remember that this is typically not constant in life; potentially Poisson distribution
maturity.V    = 1                   #age indv becomes reproductively mature
years.V       = 35
r0.V          = 1 #c(1, .8, 1.2) #0.1 #c(0.1, 0.2, 0.5)                 #per capita growth rate #0 is stable, <0 is decreasing, >0 is increasing cuz r0+1 in log growth eq
ratemort.V    = 1/(maxage.V*2) #note, I dont think this is used for anything anymore! ###0.2225 #??##(1/(maxage.V+2))      #proportion of adults that die each year --CHECK WITH JANNA WHERE THIS NUMBER CAME FROM; current value of .2225 is from Waser and Jones 1991
nSNP.mig.V    = 10
nSNP.cons.V   = 0        #number of conserved alleles within species -- used to track mutation
#generate list of parameter combinations
parameters = expand.grid(k.V, nSNP.V, miggy.V, LBhet.V, maxage.V, broodsize.V, maturity.V, years.V, r0.V, ratemort.V, nSNP.mig.V, nSNP.cons.V)
colnames(parameters) = c("k", "nSNP", "miggy", "LBhet", "maxage", "broodsize", "maturity", "years", "r0", "ratemort", "nSNP.mig", "nSNP.cons")
write.table(parameters, paste(directory, "/Output/parameters__proj___group_.csv", sep=""), sep=",", col.names=TRUE, append=FALSE, quote=FALSE, row.names=FALSE)
#clean up, remember that these are still available in parameters
remove(k.V, nSNP.V, miggy.V, LBhet.V, maxage.V, broodsize.V, maturity.V, years.V, r0.V, ratemort.V, nSNP.mig.V, nSNP.cons.V)
replicates    = 1 #20 #5 #10
plotit        = 0    #1=yes, 0=no
plotit2       = 0    #1=yes, 0=no
mutate        = 1    #1=yes, 0=no   #average mammalian genome mutation rate is 2.2 x 10^-9 per base pair per year, https://doi.org/10.1073/pnas.022629899
#krats = 2844.77 MB = 2844770000 bp x 2.2*10-9  = 6.258494 === does this matter here???
#bannertailed 0.0081 mutants/generation/locus, in Busch, Waser, and DeWoody 2007 doi: 10.1111/j.1365-294X.2007.03283.x.
mu            = 0.001  #mutation rate
styr          = 100 #year to start pop decline
nwk           = 100 #pop size after decline -- probs makes sense to keep these even in vary decline years and decline rate. should end @ same pt for all pop sizes
drp           = 10  #number of years for drop from k to nwk
dur           = 40  #duration of small pop size before pop growth
edyr          = styr+drp #150 #year to end pop decline, first year at low pop size (nwk)
s             = 5000 #(k.V*5) #size of source pop
r             = 1
#run model iterating over parameters
theEND = NULL
repEND = NULL
finalPOP = NULL
for(r in 1:nrow(parameters)){
ALL = RunModel(parameters, r, directory, replicates)
FINAL = ALL[[1]]
REP = ALL[[2]]
#POP = ALL[[2]]
####REMOVED## POP = RunModel(parameters, r, directory, replicates)
####REMOVED## write.table(POP, paste(directory, "/Output/CoverPop", r, ".csv", sep=""), sep=",", col.names=TRUE, row.names=F)
#####REMOVED##write.table(POP, paste(directory, "/Output/CoverPop.txt", sep=""), sep="\t", col.names=TRUE, row.names=F)  #use this for a .txt file, good for in a text editor. ; "/t" for macs
theEND = rbind(theEND, FINAL)
repEND = rbind(repEND, REP)
#finalPOP = rbind(finalPOP, POP)
}
source(paste(getwd(), "/RepSucc.R", sep = ''))
#run model iterating over parameters
theEND = NULL
repEND = NULL
finalPOP = NULL
for(r in 1:nrow(parameters)){
ALL = RunModel(parameters, r, directory, replicates)
FINAL = ALL[[1]]
REP = ALL[[2]]
#POP = ALL[[2]]
####REMOVED## POP = RunModel(parameters, r, directory, replicates)
####REMOVED## write.table(POP, paste(directory, "/Output/CoverPop", r, ".csv", sep=""), sep=",", col.names=TRUE, row.names=F)
#####REMOVED##write.table(POP, paste(directory, "/Output/CoverPop.txt", sep=""), sep="\t", col.names=TRUE, row.names=F)  #use this for a .txt file, good for in a text editor. ; "/t" for macs
theEND = rbind(theEND, FINAL)
repEND = rbind(repEND, REP)
#finalPOP = rbind(finalPOP, POP)
}
View(REP)
View(parameters)
View(theEND)
rep = read.table("ABM_run.1.9.23_D_all_repsuc.csv", header=T, sep=",")
setwd("C:/Users/ginab/Box/New Computer/Auburn/Data/ComplexModel_ABM/Output_local/holding") #setwd("C:/Users/Gina/Desktop/2022/ComplexModel_ABM")
directory = getwd()
outdir = paste(directory, "/figs/", sep = "")
rep = read.table("ABM_run.1.9.23_D_all_repsuc.csv", header=T, sep=",")
rep=na.omit(rep)
library(ghibli)
library(scales)
gt.cols <- ghibli_palette('PonyoMedium')#[4]
lt.gt.col <- ghibli_palette('PonyoLight')[4]
col = rep[,10]  #color by parameter
yr  = rep[,1]   #year
n   = rep[,2]   #n born
LRS = rep[,3]   #mean LRS
SD  = rep[,4]   #SD of LRS
LRSf= rep[,5]   #female LRS
LRSm= rep[,6]   #male LRS
RRS = rep[,7]   #mean RRS
SDR = rep[,8]   #SD of RRS
rep = rep[,9]   #replicate
#give each parameter set a unique identifier
rep7[,10] <- "g"
rep8[,10] <- "h"
plot(-100, -100 , xlab="year", ylab="LRS", xlim=c(min(yr), max(yr)), ylim=c(0, max(LRS)))
points(yr, LRS, col=gt.cols[col])
plot(-100, -100 , xlab="year", ylab="nborn", xlim=c(min(yr), max(yr)), ylim=c(0, max(n)))
points(yr, n, col=gt.cols[col])
plot(-100, -100 , xlab="year", ylab="RRS", xlim=c(min(yr), max(yr)), ylim=c(0, max(RRS)))
points(yr, RRS, col=gt.cols[col])
plot(-100, -100 , xlab="year", ylab="LRS of females", xlim=c(min(yr), max(yr)), ylim=c(0, max(LRSf)))
points(yr, LRSf, col=gt.cols[col])
plot(-100, -100 , xlab="year", ylab="LRS of males", xlim=c(min(yr), max(yr)), ylim=c(0, max(LRSm)))
points(yr, LRSm, col=gt.cols[col])
plot(-100, -100 , xlab="year", ylab="SD of LRS", xlim=c(min(yr), max(yr)), ylim=c(0, max(SD)))
points(yr, SD, col=gt.cols[col])
plot(-100, -100 , xlab="year", ylab="SD of RRS", xlim=c(min(yr), max(yr)), ylim=c(0, max(SDR)))
points(yr, SDR, col=gt.cols[col])
rep = read.table("ABM_run.1.11.23_C_all_repsuc.csv", header=T, sep=",")
rep=na.omit(rep)
library(ghibli)
library(scales)
gt.cols <- ghibli_palette('PonyoMedium')#[4]
lt.gt.col <- ghibli_palette('PonyoLight')[4]
col = rep[,10]  #color by parameter
yr  = rep[,1]   #year
n   = rep[,2]   #n born
LRS = rep[,3]   #mean LRS
SD  = rep[,4]   #SD of LRS
LRSf= rep[,5]   #female LRS
LRSm= rep[,6]   #male LRS
RRS = rep[,7]   #mean RRS
SDR = rep[,8]   #SD of RRS
rep = rep[,9]   #replicate
LRSmig=rep[,11] #LRS of migrants
LRSnat=rep[,12] #LRS of natives
plot(-100, -100 , xlab="year", ylab="LRS", xlim=c(min(yr), max(yr)), ylim=c(0, max(LRS)))
points(yr, LRS, col=gt.cols[col])
plot(-100, -100 , xlab="year", ylab="nborn", xlim=c(min(yr), max(yr)), ylim=c(0, max(n)))
points(yr, n, col=gt.cols[col])
plot(-100, -100 , xlab="year", ylab="RRS", xlim=c(min(yr), max(yr)), ylim=c(0, max(RRS)))
points(yr, RRS, col=gt.cols[col])
plot(-100, -100 , xlab="year", ylab="LRS of females", xlim=c(min(yr), max(yr)), ylim=c(0, max(LRSf)))
points(yr, LRSf, col=gt.cols[col])
plot(-100, -100 , xlab="year", ylab="LRS of males", xlim=c(min(yr), max(yr)), ylim=c(0, max(LRSm)))
points(yr, LRSm, col=gt.cols[col])
plot(-100, -100 , xlab="year", ylab="SD of LRS", xlim=c(min(yr), max(yr)), ylim=c(0, max(SD)))
points(yr, SD, col=gt.cols[col])
plot(-100, -100 , xlab="year", ylab="SD of RRS", xlim=c(min(yr), max(yr)), ylim=c(0, max(SDR)))
points(yr, SDR, col=gt.cols[col])
plot(-100, -100 , xlab="year", ylab="LRS of migrants", xlim=c(min(yr), max(yr)), ylim=c(0, max(LRSmig)))
points(yr, LRSmig, col=gt.cols[col])
plot(-100, -100 , xlab="year", ylab="Ho", xlim=c(0, max(yr)), ylim=c((min(Ho)), (max(Ho)+.1)))
plot(-100, -100 , xlab="year", ylab="LRS", xlim=c(min(yr), max(yr)), ylim=c(0, max(LRS)))
head(rep)
head(col)
table(col)
legend('middle', legend = c('mig=0', 'mig=1migpergen','mig=1xof50@175','mig=3xpf25@175|201|225'), col = gt.cols, pch = 19, bty = 'n', cex = text.size, pt.cex = pt.cex, horiz = TRUE, x.intersp = 0.5)
legend('center', legend = c('mig=0', 'mig=1migpergen','mig=1xof50@175','mig=3xpf25@175|201|225'), col = gt.cols, pch = 19, bty = 'n', cex = text.size, pt.cex = pt.cex, horiz = TRUE, x.intersp = 0.5)
legend('center', legend = c('mig=0', 'mig=1migpergen','mig=1xof50@175','mig=3xpf25@175|201|225'), col = gt.cols, pch = 19, bty = 'n', cex = 1.75, pt.cex = 1.25, horiz = TRUE, x.intersp = 0.5)
legend('center', legend = c('mig=0', 'mig=1migpergen','mig=1xof50@175','mig=3xpf25@175|201|225'), col = gt.cols, pch = 19, bty = 'n', cex = 1.75, pt.cex = 1.25, horiz = FALSE, x.intersp = 0.5)
plot(-100, -100 , xlab="year", ylab="LRS", xlim=c(min(yr), max(yr)), ylim=c(0, max(LRS)))
legend('center', legend = c('mig=0', 'mig=1migpergen','mig=1xof50@175','mig=3xpf25@175|201|225'), col = gt.cols, pch = 19, bty = 'n', cex = 1.75, pt.cex = 1.25, horiz = FALSE, x.intersp = 0.5)
legend('center', legend = c('mig=0', 'mig=1migpergen','mig=1xof50@175','mig=3xpf25@175|201|225'), col = gt.cols, pch = 19, bty = 'n', cex = 1.75, pt.cex = 2, horiz = FALSE, x.intersp = 0.5)
rep = read.table("ABM_run.1.11.23_C_all_repsuc.csv", header=T, sep=",")
View(rep)
