source(paste(getwd(), "/Breed.R", sep = ''))
if(numboff >= 1){
ttt = Breed(pop, pairs, numboff, k, sz, nSNP, nSNP.mig, broodsize, y, mu, mutate, nSNP.cons) #still needs work
pop = ttt[[1]]
bb = ttt[[2]]
sz = sz + bb
}else if(numboff <= 0){
print(paste("No new babies, skip breed"))
#next
}
#randomly select pairings from pairs so that there are double the number of pairs than offspring needed to be generated (since broodsize can be 0)
if(is.null(nrow(pairs))==TRUE){
print(paste("no pairs of parents available"))
break
}else if(nrow(pairs)>= numboff*2){
pairings = sample(1:nrow(pairs), numboff*2, replace = F, prob = NULL)
}else{
pairings = sample(1:nrow(pairs), numboff, replace = T, prob = NULL) ### DOUBLE CHECK THAT replace=T does not fuck this up, error tends to occurr when numboff = 2
}
parents <- pairs[pairings,]
#generate fecundity for each set of parents
fecundity = sample(seq(1,broodsize,1),nrow(parents),replace=T, prob = NULL) #change the number of offspring to biologically relevant number later
parents <- cbind(parents, fecundity)
nbabes = sum(parents[,3])
TEMP = NULL
for(n in 1:nrow(parents)){
t = parents[n, ,drop=FALSE] #need drop = false or else will lose
f = t[1,3]       #use this to store the number of offspring per parent set
t[1,3] = 1       #use this as a check for later on to make sure this loop works
while(f > 0){
TEMP = rbind(TEMP, t)
f = f - 1
if(f==0){       #another check so it doesnt get stuck in this loop
break
}
}
}
parents = TEMP
remove(TEMP)
#generate unique IDS
##REMOVED### newid = seq(from = (max(pop[,1])*10) +1, to = (max(pop[,1])*10) + nrow(parents), by = 1)
SZ = seq(from = sz+1, to = sz + nrow(parents), by =1)
babies = matrix(nrow=nrow(parents), ncol=12) #make new matrix for offspring
colnames(babies) <- c("id", "mom", "dad", "age", "sex", "n offspring", "n adult offspring", "alive", "gen born", "gen died", "relative fitness", "prop migrant SNPs")
babies[,1] = SZ                   #each individual has unique ID name; sequence starting at 1, through k, with each 1 iteration
babies[,2] = parents[,1]
babies[,3] = parents[,2]
babies[,4] = 0    #first of the year - consider if these should be 0 or -1
babies[,5] = sample(c(0,1),nrow(babies),replace=T)    #each individual assigned male (1) or female (0) #sample from zero nrow times, with replacements. aka set sex
babies[,6] = NA #REMOVED##0                #####sample(c(0,1),nrow(babies),replace=T)    #set allele 1 as either A=1 or a=0
babies[,7] = NA                 #####sample(c(0,1),nrow(babies),replace=T)    #set allele 2 as either A=1 or a=0
babies[,8] = 1      #make every baby alive
babies[,9] = y  #MUST feed y to function   #generation born
babies[,10] = 0      #generation died
babies[,11] = NA      #relative fitness
babies[,12] = NA                            #proportion of migrant SNPs - initial pop will all be 1
#create a check to make sure the correct number of babies are being added to pop
if(nrow(babies) < numboff){
print("no reproduction")
return(list(pop,0))
}
if(nrow(babies) >= numboff){
if(numboff == nrow(babies)){
bb = nrow(babies)
}
if(nrow(babies) > numboff){
rm = sample(babies[,1], nrow(babies)-numboff, replace = FALSE, prob = NULL) #remove babies so that you generate only the number needed
babies = babies[-which(babies[,1]%in%rm), , drop=FALSE]
bb = nrow(babies)
}
if(is.null(nrow(babies))==TRUE){
bb = 1
print(paste("only one new baby"))
#singlebabe = NULL
#singlebabe = matrix(1:8,nrow = 1)
#bby = rbind(babies,singlebabe)
#NEED TO FIGURE OUT SOLUTION FOR WHEN THERE IS ONLY ONE BABY
##ERROR WILL CONTINUE ON LINE 79 UNTIL RESOLVED
}
#rename babies so count doesnt get messed up
babies =  as.matrix(babies)
babies[,1] = seq(from = (sz+1), to = (sz+bb), by = 1)
#genotypes
#prep parent genotypes
f = babies[,2]
m = babies[,3]
fem = pop[-which(pop[,1]%NOTin%f), , drop = FALSE]
mal = pop[-which(pop[,1]%NOTin%m), , drop = FALSE]
if(nrow(mal) == 0){
print(paste("can't generate father genotypes"))
break
}
if(nrow(fem)==0){
print(paste("can't generate mother genotypes"))
break
}
SNPS = (nSNP*2) + (nSNP.mig*2) + (nSNP.cons*2)
babygeno = matrix(nrow=bb, ncol=SNPS)
#loop over each row in babies
for(i in 1:nrow(babies)){
mom = babies[i,2]
dad = babies[i,3]
mm = pop[pop[,1] == mom, , drop=FALSE]
dd = pop[pop[,1] == dad, , drop=FALSE]
momgeno = mm[, -c(ncol(mm)-(SNPS):ncol(mm))]
dadgeno = dd[, -c(ncol(dd)-(SNPS):ncol(dd))]
#allele 1 positions, aka odd values
pos1 = seq(1, SNPS, 2)
pos2 = pos1+1
#from each snp (2 columns), grab 1 of mom's alleles
momgeno.s = pos1 + (sample(0:1, length(pos1), replace=T)) #list of values to pull, exactly 1 allele (here it is index number) from each set of two columns
momgeno.s = momgeno[momgeno.s] #these are now the actual alleles
#from each snp (2 columns), grab 1 of dad's alleles
dadgeno.s = pos1 + (sample(0:1, length(pos1), replace=T)) #list of values to pull, exactly 1 allele (here it is index number) from each set of two columns
dadgeno.s = dadgeno[dadgeno.s] #these are now the actual alleles
#now need to interweve mom and dad's genos so that the loci are jumbled
babygeno[i,pos1] = momgeno.s
babygeno[i,pos2] = dadgeno.s
}
if(mutate == 1){  #if mutate is turned "on"
for(x in 1:nrow(babygeno)){    #iterate over indv
mut <- sample(c("Y","N"), SNPS, replace = TRUE, prob = c(mu,1-mu))
init <- babygeno[x,] ## keep track of the 'ancestral' state within this individual
babygeno[x, which(mut=='Y' & babygeno[x,]==1)] <- 0
## if a SNP is supposed to mutate, but its ancestral state was '1' (i.e., it's already been mutated in the previous line),
## then set its index in mut to 'N', indicating that no further mutations should happen in this round.
mut[which(mut=='Y' & init==1)] <- 'N'
babygeno[x, which(mut=='Y' & babygeno[x,]==0)] <- 1
}
}else{
print(paste("no mutation"))
}
#calculate relative fitness (heterozygosity)
het <- matrix(nrow=nrow(babygeno), ncol=1)
for(g in 1:nrow(babygeno)){
w <- sum(babygeno[g ,seq(1,ncol(babygeno),2)]!=babygeno[g,seq(2,ncol(babygeno),2)])/(ncol(babygeno)/2)
het[g,1] <- w
}
babies[,11] <- het
#note that all SNPs are being considered here -- might want to separate out mig/drift SNPs
#calculate proportion of migrant SNPs
migrantgen <- babygeno[, -c(ncol(babygeno)-(nSNP.mig*2):ncol(babygeno))]
mSNP <- matrix(nrow=bb,ncol=1)
for(q in 1:nrow(migrantgen)){
ww <- sum(migrantgen[q,])/ncol(migrantgen)
mSNP[q,1] <- ww
}
babies[,12] <- mSNP
#note this might break when bb=1; need to figure that out
babies = cbind(babies, babygeno)
pop = rbind(pop, babies)
return(list(pop,bb))
}
babies[,11]
babies
#calculate proportion of migrant SNPs
migrantgen <- babygeno[, -c(ncol(babygeno)-(nSNP.mig*2):ncol(babygeno))]
migrantgen
bb
ncol(babygeno)-(nSNP.mig*2):ncol(babygeno)
nSNP.mig*2
matrix(unlist(migrantgen), ncol = bb, nrow = nSNP.mig*2)
matrix(unlist(migrantgen), ncol = nSNP.mig*2, nrow = bb)
mSNP <- matrix(nrow = bb,ncol = 1)
for(q in 1:nrow(migrantgen)){
ww <- sum(migrantgen[q,])/ncol(migrantgen)
mSNP[q,1] <- ww
}
#calculate proportion of migrant SNPs
migrantgen <- babygeno[, -c(ncol(babygeno)-(nSNP.mig*2):ncol(babygeno))]
migrantgen
migrantgen <- matrix(unlist(migrantgen), ncol = nSNP.mig*2, nrow = bb)
migrantgen
mSNP <- matrix(nrow = bb,ncol = 1)
#calculate proportion of migrant SNPs
migrantgen <- babygeno[, -c(ncol(babygeno)-(nSNP.mig*2):ncol(babygeno))]
migrantgen <- matrix(unlist(migrantgen), nrow = bb, ncol = nSNP.mig*2)
migrantgen
mSNP <- matrix(nrow = bb, ncol = 1)
for(q in 1:nrow(migrantgen)){
ww <- sum(migrantgen[q,])/ncol(migrantgen)
mSNP[q,1] <- ww
}
babies[,12] <- mSNP
babies
babies = cbind(babies, babygeno)
pop = rbind(pop, babies)
source(paste(getwd(), "/Breed.R", sep = ''))
#REMOVED## if(sum(pairs[,1]) < 0 | sum(pairs[,2]) < 0){
#REMOVED##   print(paste("Only migrants available as parents"))
#REMOVED##   break
#REMOVED## }
pp = PopSizeNext(pop, k, r0, maturity, y, styr, endyr, nwk, dur, parameters, r, K) #ADD NEW K MODIFIER
numboff = pp[[1]]
K = pp[[2]]
if(numboff >= 1){
ttt = Breed(pop, pairs, numboff, k, sz, nSNP, nSNP.mig, broodsize, y, mu, mutate, nSNP.cons) #still needs work
pop = ttt[[1]]
bb = ttt[[2]]
sz = sz + bb
}else if(numboff <= 0){
print(paste("No new babies, skip breed"))
#next
}
tail(po)
tail(pop)
ncol(pop)
pop[,52]=1
tail(pop)
pop = AgeDeath(pop, maxage, ratemort, y)                #kill indv based on age
if(sum(pop[,8]) <= 10){
print(paste("CRASH @ AgeDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, focalpop, source1, y, init.het, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K)
FINAL = rbind(FINAL, out[1,])
break
}
print(paste("DONE!", y, "rep", rr))
y=2
pop = AgeUp(pop)                        #age pop + 1 year
pop = FitnessDeath(pop, maturity, ratemort, y)                #kill indv
#pop = DeathByAge(pop, maxage)           #age-dependent mortality
if(sum(pop[,8]) <= 10){
print(paste("Crash @ FitnessDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, focalpop, source1, y, init.het, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K)
FINAL = rbind(FINAL, out[1,])
break
}
#pop = RandomDeath(pop)                  #random mortality
tt = Migrate(pop, source, y, miggy)             #subpop migration
pop = tt[[1]]
mig = tt[[2]]  #0
sz = sz + mig #may need to edit since dead are not being removed from pop
source = tt[[3]]
if(sum(pop[,8]) <= 4){
print(paste("Population crash @ MateChoice, less than 4 indv"))
out = Analyze(parameters, r, pop, mig, focalpop, source1, y, init.het, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K)
FINAL = rbind(FINAL, out[1,])
break
}
pairs = MateChoice(pop, sex, maturity)
if(is.null(pairs)==TRUE){
print(paste("skipping pop size next, breed due to no parents"))
out = Analyze(parameters, r, pop, mig, focalpop, source1, y, init.het, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K)
FINAL = rbind(FINAL, out[1,])
break  #consider whether this should be next or break
}
#REMOVED## if(sum(pairs[,1]) < 0 | sum(pairs[,2]) < 0){
#REMOVED##   print(paste("Only migrants available as parents"))
#REMOVED##   break
#REMOVED## }
pp = PopSizeNext(pop, k, r0, maturity, y, styr, endyr, nwk, dur, parameters, r, K) #ADD NEW K MODIFIER
numboff = pp[[1]]
K = pp[[2]]
numboff
tail(pop)
if(numboff >= 1){
ttt = Breed(pop, pairs, numboff, k, sz, nSNP, nSNP.mig, broodsize, y, mu, mutate, nSNP.cons) #still needs work
pop = ttt[[1]]
bb = ttt[[2]]
sz = sz + bb
}else if(numboff <= 0){
print(paste("No new babies, skip breed"))
#next
}
tail(pop)
#get variables for run -- I think this can be copied from RunModel.R
k             = parameters$k[r]
#REMOVED###allele        = parameters$allele[r]
nSNP          = parameters$nSNP[r]
miggy         = parameters$miggy[r]
LBhet         = parameters$LBhet[r]
#REMOVED###nMicro        = parameters$nMicro[r]
#REMOVED###sex           = parameters$sex[r]
maxage        = parameters$maxage[r]
broodsize     = parameters$broodsize[r]
#REMOVED###sexratio      = parameters$sexratio[r]
maturity      = parameters$maturity[r]
years         = parameters$years[r]
r0            = parameters$r0[r]
ratemort      = parameters$ratemort[r]
nSNP.mig      = parameters$nSNP.mig[r]
nSNP.cons     = parameters$nSNP.cons[r]                  #number of conserved alleles
#check for indv ID numbers
if(!length(pop[,1])==length(unique(pop[,1]))){ #notice that ! means NOT
print(r)
print("NON UNIQUE ID NUMBERS")
return()
}
#if no indv, exit
if(length(pop[,1])==0){return()}
#SHOULD THESE BE ALL INDV OR ONLY ALIVE??
#separate out alive indv
alive = pop[pop[,8]==1, , drop=FALSE]
#calculate summary stats for final pop
FIN = matrix(nrow=years+1, ncol=17)
colnames(FIN) = c("year", "popsize", "propmig", "He", "Ho", "Fis", "nadults", "sxratio", "nmig", "Fst", "replicate", "parameterset", "numboff", "FstVSource", "FisVSource", "deltaK", "propMigSNPs")
f = 1
#for(f in 1:nrow(FIN)){
#year = FIN[f,1] #-1 #doing this cuz also taking year 0 -- note that on 5/2/22 there were still errors with numbering on column 1
FIN[f,1] <- y
FIN[f,16] <- K
FIN
#separate out alive in current year -- Janna did these from year born and year died column
data = alive[alive[,8]>0, , drop = FALSE]
x=NULL
x = try(length(data[,1]), silent=TRUE)
if(is.null(x)){break}
if(x<1){break}
if(!is.numeric(x)){break}
#number of indv
FIN[f,2] = nrow(data)
#proportion migrants in population
FIN[f,3] =  sum(data[,2]==-1)/length(data[,1])   #1 - sum(data[,2]==-1)/length(data[,1])
#proportion of migrant genotypes in population
FIN[f,17] <- mean(data[,12])
#He and Ho - neutral (?)    ==== note that Ho might already by calc at pop[,11]
SNPS = (nSNP*2) + (nSNP.mig*2) + (nSNP.cons*2)
genotype = data[, -c(ncol(data)-SNPS:ncol(data))] #THERE IS AN ERROR HERE THAT IS CHANGING THE ORDER OF COLUMNS?? ALSO NOTE THAT THE NUMBER OF SNPS IS WRONG--PROBS CUZ OF NOT RUNNING THE DIFFERENT TYPES IN RUNMODEL. FIX THIS~!
snps = rep(c(1,2),ncol(genotype)/2)
HE = NULL
HO = NULL
loc.pos = seq(1, SNPS, 2)
for(lp in loc.pos){
#per locus heterozygostiy
locus <- genotype[, c(lp, lp+1), drop=FALSE]
#REMOVED because calculated already
#geno  <- length(locus[,1])
#het   <- length(which(locus[,1] != locus[,2]))
#het.observed <- het/geno
#HO = c(HO, het.observed)
freqs <- table(locus)
homozygous = NULL
for(v in 1:length(freqs)){
homozygous = c(homozygous, (freqs[v]/sum(freqs)*freqs[v]/sum(freqs)))
}
het.expected <- 1 - sum(homozygous)
HE = c(HE, het.expected)
}
FIN[f,4] <- mean(HE)
FIN[f,5] <- mean(data[,11])
FIN
if(y == 0){
K = k
}
#analyze each replicate
out = Analyze(parameters, r, pop, mig, focalpop, source1, y, init.het, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K)
setwd("C:/Users/ginab/Box/New Computer/Auburn/Data/ComplexModel_ABM/ABM_sep2022")
directory = getwd()
outdir = paste(directory, "/Output/", sep = "")
source(paste(directory, "/Source/FunctionSourcer.R", sep = ''))
directory
#set working directory, import packages, source functions,
setwd(paste(directory,"/Source/", sep = '')) #set temp working directory
#library()
library(reshape2)   #commented out 10/4/22 cuz I was getting pissed. I think this is just for plotting
library(adegenet)   #commented out 10/4/22 cuz I was getting pissed. I think this is just for plotting
library(scales) #may need this for plotting, this allows transparency in colors for overlapping lines
#library()
library(reshape2)   #commented out 10/4/22 cuz I was getting pissed. I think this is just for plotting
library(adegenet)   #commented out 10/4/22 cuz I was getting pissed. I think this is just for plotting
library(scales) #may need this for plotting, this allows transparency in colors for overlapping lines
library(matrixStats) #need this for colCount and rowCount in ReproSuc.R
library(hierfstat)   #need this for FST analysis in Analyze.R
library(tidyr)       #need this for FST analysis in Analyze.R
library(gtools)      #commented out 10/4/22 cuz I was getting pissed. I think this is just for plotting
'%NOTin%' <- Negate(`%in%`) #this defines the not in function so that I can select identities that are not defined by something (see RandomDeaths.R for an example)
#source functions
source(paste(getwd(), "/RunModel.R", sep = ''))
source(paste(getwd(), "/AgeUp.R", sep = ''))
source(paste(getwd(), "/AgeDeath.R", sep = ''))
source(paste(getwd(), "/FitnessDeath.R", sep = ''))
source(paste(getwd(), "/Migrate.R", sep = ''))
source(paste(getwd(), "/MateChoice.R", sep = ''))
source(paste(getwd(), "/PopSizeNext.R", sep = ''))
source(paste(getwd(), "/Breed.R", sep = ''))
source(paste(getwd(), "/Analyze.R", sep = ''))
source(paste(getwd(), "/Plot.R", sep = ''))       #on/off switch
source(paste(getwd(), "/Plot2.R", sep = ''))       #on/off switch
source(paste(getwd(), "/RepSucc.R", sep = ''))
k.V           = 50
nSNP.V        = 10
miggy.V       = 0 #c(0,"a","b","c")  #"a"=one mig per gen, "b"=1xof50@175, "c"=3xpf25@175|201|225  #migration parameter type
LBhet.V       = 0.1 #c(0.1, 0.45, 0.8) #lowerbound limit  #c(0.4, 0.6) #c(0.8, 0.9)   #THINK ABOUT THE BEST WAY TO SET THIS UP -- either give the values for lower bound and then in RunModel, +1 for upper bound. or change the lower and upper depending on the run
maxage.V      = 9     #low ages dont work              #maximum age individuals can be; add one at first, so they will die at 4, start at -1
broodsize.V   = 2     #this is now the MAX brood size, aka max fecundity   #REMOVED##c(0:2)              #aka fecundity, remember that this is typically not constant in life; potentially Poisson distribution
maturity.V    = 1                   #age indv becomes reproductively mature
years.V       = 350  #scaleup               #total run time; 200 year run following 50 year stabilization period
r0.V          = 1 #c(1, .8, 1.2) #0.1 #c(0.1, 0.2, 0.5)                 #per capita growth rate #1 is stable, <1 is decreasing, >1 is increasing
ratemort.V    = 1/(maxage.V*2) ###0.2225 #??##(1/(maxage.V+2))      #proportion of adults that die each year --CHECK WITH JANNA WHERE THIS NUMBER CAME FROM; current value of .2225 is from Waser and Jones 1991
nSNP.mig.V    = 10
nSNP.cons.V   = 0        #number of conserved alleles within species -- used to track mutation
#generate list of parameter combinations
parameters = expand.grid(k.V, nSNP.V, miggy.V, LBhet.V, maxage.V, broodsize.V, maturity.V, years.V, r0.V, ratemort.V, nSNP.mig.V, nSNP.cons.V)
colnames(parameters) = c("k", "nSNP", "miggy", "LBhet", "maxage", "broodsize", "maturity", "years", "r0", "ratemort", "nSNP.mig", "nSNP.cons")
write.table(parameters, paste(directory, "/Output/parameters__proj___group_.csv", sep=""), sep=",", col.names=TRUE, append=FALSE, quote=FALSE, row.names=FALSE)
#clean up, remember that these are still available in parameters
remove(nSNP.V, miggy.V, LBhet.V, maxage.V, broodsize.V, maturity.V, years.V, r0.V, ratemort.V, nSNP.mig.V, nSNP.cons.V) #k.V
replicates    = 1 #20 #5 #10
plotit        = 0    #1=yes, 0=no
plotit2       = 0    #1=yes, 0=no
mutate        = 1    #1=yes, 0=no   #average mammalian genome mutation rate is 2.2 x 10^-9 per base pair per year, https://doi.org/10.1073/pnas.022629899
#krats = 2844.77 MB = 2844770000 bp x 2.2*10-9  = 6.258494 === does this matter here???
#bannertailed 0.0081 mutants/generation/locus, in Busch, Waser, and DeWoody 2007 doi: 10.1111/j.1365-294X.2007.03283.x.
mu            = 0.001  #mutation rate
styr          = 100 #year to start pop decline
nwk           = 25 #pop size after decline -- probs makes sense to keep these even in vary decline years and decline rate. should end @ same pt for all pop sizes
dur           = 100  #duration of small pop size before pop growth
edyr          = styr+dur #150 #year to end pop decline, first year at low pop size
s             = 5000 #(k.V*5) #size of source pop
r             = 1
#run model iterating over parameters
theEND = NULL
repEND = NULL
finalPOP = NULL
for(r in 1:nrow(parameters)){
ALL = RunModel(parameters, r, directory, replicates)
FINAL = ALL[[1]]
POP = ALL[[2]]
REP = ALL[[3]]
####REMOVED## POP = RunModel(parameters, r, directory, replicates)
####REMOVED## write.table(POP, paste(directory, "/Output/CoverPop", r, ".csv", sep=""), sep=",", col.names=TRUE, row.names=F)
#####REMOVED##write.table(POP, paste(directory, "/Output/CoverPop.txt", sep=""), sep="\t", col.names=TRUE, row.names=F)  #use this for a .txt file, good for in a text editor. ; "/t" for macs
theEND = rbind(theEND, FINAL)
repEND = rbind(repEND, REP)
finalPOP = rbind(finalPOP, POP)
}
View(theEND)
setwd("C:/Users/ginab/Box/New Computer/Auburn/Data/ComplexModel_ABM/ABM_sep2022")
directory = getwd()
outdir = paste(directory, "/Output/", sep = "")
#set working directory, import packages, source functions,
setwd(paste(directory,"/Source/", sep = '')) #set temp working directory
#library()
library(reshape2)   #commented out 10/4/22 cuz I was getting pissed. I think this is just for plotting
library(adegenet)   #commented out 10/4/22 cuz I was getting pissed. I think this is just for plotting
library(scales) #may need this for plotting, this allows transparency in colors for overlapping lines
library(matrixStats) #need this for colCount and rowCount in ReproSuc.R
library(hierfstat)   #need this for FST analysis in Analyze.R
library(tidyr)       #need this for FST analysis in Analyze.R
library(gtools)      #commented out 10/4/22 cuz I was getting pissed. I think this is just for plotting
'%NOTin%' <- Negate(`%in%`) #this defines the not in function so that I can select identities that are not defined by something (see RandomDeaths.R for an example)
#source functions
source(paste(getwd(), "/RunModel.R", sep = ''))
source(paste(getwd(), "/AgeUp.R", sep = ''))
source(paste(getwd(), "/AgeDeath.R", sep = ''))
source(paste(getwd(), "/FitnessDeath.R", sep = ''))
source(paste(getwd(), "/Migrate.R", sep = ''))
source(paste(getwd(), "/MateChoice.R", sep = ''))
source(paste(getwd(), "/PopSizeNext.R", sep = ''))
source(paste(getwd(), "/Breed.R", sep = ''))
source(paste(getwd(), "/Analyze.R", sep = ''))
source(paste(getwd(), "/Plot.R", sep = ''))       #on/off switch
source(paste(getwd(), "/Plot2.R", sep = ''))       #on/off switch
source(paste(getwd(), "/RepSucc.R", sep = ''))
k.V           = 50
nSNP.V        = 10
miggy.V       = 0 #c(0,"a","b","c")  #"a"=one mig per gen, "b"=1xof50@175, "c"=3xpf25@175|201|225  #migration parameter type
LBhet.V       = 0.1 #c(0.1, 0.45, 0.8) #lowerbound limit  #c(0.4, 0.6) #c(0.8, 0.9)   #THINK ABOUT THE BEST WAY TO SET THIS UP -- either give the values for lower bound and then in RunModel, +1 for upper bound. or change the lower and upper depending on the run
maxage.V      = 9     #low ages dont work              #maximum age individuals can be; add one at first, so they will die at 4, start at -1
broodsize.V   = 2     #this is now the MAX brood size, aka max fecundity   #REMOVED##c(0:2)              #aka fecundity, remember that this is typically not constant in life; potentially Poisson distribution
maturity.V    = 1                   #age indv becomes reproductively mature
years.V       = 350  #scaleup               #total run time; 200 year run following 50 year stabilization period
r0.V          = 1 #c(1, .8, 1.2) #0.1 #c(0.1, 0.2, 0.5)                 #per capita growth rate #1 is stable, <1 is decreasing, >1 is increasing
ratemort.V    = 1/(maxage.V*2) ###0.2225 #??##(1/(maxage.V+2))      #proportion of adults that die each year --CHECK WITH JANNA WHERE THIS NUMBER CAME FROM; current value of .2225 is from Waser and Jones 1991
nSNP.mig.V    = 10
nSNP.cons.V   = 0        #number of conserved alleles within species -- used to track mutation
#generate list of parameter combinations
parameters = expand.grid(k.V, nSNP.V, miggy.V, LBhet.V, maxage.V, broodsize.V, maturity.V, years.V, r0.V, ratemort.V, nSNP.mig.V, nSNP.cons.V)
colnames(parameters) = c("k", "nSNP", "miggy", "LBhet", "maxage", "broodsize", "maturity", "years", "r0", "ratemort", "nSNP.mig", "nSNP.cons")
write.table(parameters, paste(directory, "/Output/parameters__proj___group_.csv", sep=""), sep=",", col.names=TRUE, append=FALSE, quote=FALSE, row.names=FALSE)
#clean up, remember that these are still available in parameters
remove(nSNP.V, miggy.V, LBhet.V, maxage.V, broodsize.V, maturity.V, years.V, r0.V, ratemort.V, nSNP.mig.V, nSNP.cons.V) #k.V
replicates    = 1 #20 #5 #10
plotit        = 0    #1=yes, 0=no
plotit2       = 0    #1=yes, 0=no
mutate        = 1    #1=yes, 0=no   #average mammalian genome mutation rate is 2.2 x 10^-9 per base pair per year, https://doi.org/10.1073/pnas.022629899
#krats = 2844.77 MB = 2844770000 bp x 2.2*10-9  = 6.258494 === does this matter here???
#bannertailed 0.0081 mutants/generation/locus, in Busch, Waser, and DeWoody 2007 doi: 10.1111/j.1365-294X.2007.03283.x.
mu            = 0.001  #mutation rate
styr          = 100 #year to start pop decline
nwk           = 25 #pop size after decline -- probs makes sense to keep these even in vary decline years and decline rate. should end @ same pt for all pop sizes
dur           = 100  #duration of small pop size before pop growth
edyr          = styr+dur #150 #year to end pop decline, first year at low pop size
s             = 5000 #(k.V*5) #size of source pop
r             = 1
#run model iterating over parameters
theEND = NULL
repEND = NULL
finalPOP = NULL
for(r in 1:nrow(parameters)){
ALL = RunModel(parameters, r, directory, replicates)
FINAL = ALL[[1]]
POP = ALL[[2]]
REP = ALL[[3]]
####REMOVED## POP = RunModel(parameters, r, directory, replicates)
####REMOVED## write.table(POP, paste(directory, "/Output/CoverPop", r, ".csv", sep=""), sep=",", col.names=TRUE, row.names=F)
#####REMOVED##write.table(POP, paste(directory, "/Output/CoverPop.txt", sep=""), sep="\t", col.names=TRUE, row.names=F)  #use this for a .txt file, good for in a text editor. ; "/t" for macs
theEND = rbind(theEND, FINAL)
repEND = rbind(repEND, REP)
finalPOP = rbind(finalPOP, POP)
}
View(theEND)
tail(pop)
pop
tail(finalPOP)
sum(finalPOP[,(ncol(pop))])
ncol(pop)
ncol(POP)
sum(finalPOP[,(ncol(POP))])
sum(finalPOP[,52])
sum(finalPOP[,51])
nrow(POP)
