#NOTE this includes MigSNPS while the other het value does not
geno  <- length(locus[,1])
het   <- length(which(locus[,1] != locus[,2]))
het.observed <- het/geno
HO = c(HO, het.observed)
freqs <- table(locus)
homozygous = NULL
for(v in 1:length(freqs)){
homozygous = c(homozygous, (freqs[v]/sum(freqs)*freqs[v]/sum(freqs)))
}
het.expected <- 1 - sum(homozygous)
HE = c(HE, het.expected)
}
FIN[f,4] <- mean(HE)
FIN[f,5] <- mean(data[,11])
FIN[f,18] <- mean(HO)
#find number of adults per year
adults = data[data[,4]>= maturity, , drop = FALSE]
FIN[f,7] = nrow(adults)
########################################NEW####################################3
#find the sex ratio
FIN[f,8] = mean(data[,'sex']) #<0.5 female, >.5 male
#note number of migrants
if(y != 0){
FIN[f,9] = mig  #generated in Migrate.R, passed to RunModel.R, and passed here in Analyze.R
}else{
FIN[f,9] = 0  #this is for year 0, there are no migrants in this pop
}
#prepare the genotypes for hierfstat
SNPS = (nSNP*2) + (nSNP.mig*2) + (nSNP.cons*2)                    #find number of SNPs
fstdata <- data[, -c(ncol(data)-(SNPS):ncol(data))]               #grab SNPs
#change 0s to 2s for hierfstat to read
fstdata[fstdata[,]==0] <-2
#allele 1 positions, aka odd values
pos1 = seq(1, SNPS, 2)
pos2 = pos1+1
#merge pos1 and pos2 into pos1, then remove pos2
fstdata[,pos1] <- as.numeric(paste(fstdata[,pos1], fstdata[,pos2], sep=""))
fstdata <- fstdata[,-c(pos2)]
#add pop identifier for calculations
popident <- matrix(nrow=nrow(fstdata), ncol=1)
popident[,1] = y
fstdata <- cbind(popident,fstdata)
if(y != 0){
#do the same to the initialized focal pop -- for comparison
#MOVEDTORUNMODEL##fstinit <- focalpop[, -c(ncol(focalpop)-(SNPS):ncol(focalpop))]               #grab SNPs
#MOVEDTORUNMODEL##fstinit[fstinit[,]==0] <-2                                                    #change 0s to 2s
#MOVEDTORUNMODEL##fstinit[,pos1] <- as.numeric(paste(fstinit[,pos1], fstinit[,pos2], sep=""))                     #merge SNPs
#MOVEDTORUNMODEL##fstinit <- fstinit[,-c(pos2)]                                                 #remove single pos2 SNPs
#MOVEDTORUNMODEL##initident <- matrix(nrow=nrow(fstinit), ncol=1)                               #add pop identifier
#MOVEDTORUNMODEL##initident[,1] = 0
#MOVEDTORUNMODEL##fstinit <- cbind(initident,fstinit)                                           #merge identifier and genotypes
fstnow <- rbind(fstdata, fstinit)                                            #merge current year and initialized year to one matrix for calculations
fstnow <- as.data.frame(fstnow)                                               #turn into a dataframe
calc <-wc(fstnow, diploid=TRUE, pol=0)                                         #calc FST and FIS
#calc <- pairwise.WCfst(fstdata,diploid=TRUE)                                   #calculate FST
FIN[f,10] <- calc$FST
FIN[f,6] <- calc$FIS
#do the same to the initialized source pop -- for comparison
#MOVEDTORUNMODEL##fstsource <- source1[, -c(ncol(source1)-(SNPS):ncol(source1))]                    #grab SNPs
#MOVEDTORUNMODEL##fstsource[fstsource[,]==0] <-2                                                    #change 0s to 2s
#MOVEDTORUNMODEL##fstsource[,pos1] <- as.numeric(paste(fstsource[,pos1], fstsource[,pos2], sep=""))                     #merge SNPs
#MOVEDTORUNMODEL##fstsource <- fstsource[,-c(pos2)]                                                 #remove single pos2 SNPs
#MOVEDTORUNMODEL##sourceident <- matrix(nrow=nrow(fstsource), ncol=1)                               #add pop identifier
#MOVEDTORUNMODEL##sourceident[,1] = -1
#MOVEDTORUNMODEL##fstsource <- cbind(sourceident,fstsource)                                         #merge identifier and genotypes
#REMOVEDTOSPEEDUP##fstdatavsource <- rbind(fstdata, fstsource)                                              #merge current year and initialized year to one matrix for calculations
#REMOVEDTOSPEEDUP##fstdatavsource <- as.data.frame(fstdatavsource)
#REMOVEDTOSPEEDUP##calcvsource <-wc(fstdatavsource, diploid=TRUE, pol=0)
#REMOVEDTOSPEEDUP##FIN[f,14] <- calcvsource$FST
#REMOVEDTOSPEEDUP##FIN[f,15] <- calcvsource$FIS
}
if(y == 0){
#do the same to the initialized source pop -- for comparison
#MOVEDTORUNMODEL##fstsource <- source1[, -c(ncol(source1)-(SNPS):ncol(source1))]                    #grab SNPs
#MOVEDTORUNMODEL##fstsource[fstsource[,]==0] <-2                                                    #change 0s to 2s
#MOVEDTORUNMODEL##fstsource[,pos1] <- as.numeric(paste(fstsource[,pos1], fstsource[,pos2], sep=""))                     #merge SNPs
#MOVEDTORUNMODEL##fstsource <- fstsource[,-c(pos2)]                                                 #remove single pos2 SNPs
#MOVEDTORUNMODEL##sourceident <- matrix(nrow=nrow(fstsource), ncol=1)                               #add pop identifier
#MOVEDTORUNMODEL##sourceident[,1] = -1
#MOVEDTORUNMODEL##fstsource <- cbind(sourceident,fstsource)                                         #merge identifier and genotypes
fstyo <- rbind(fstinit, fstsource) #merge current year and initialized year to one matrix for calculations
fstyo <- as.data.frame(fstyo)                                               #turn into a dataframe
calcyo <-wc(fstyo, diploid=TRUE, pol=0)                                         #calc FST and FIS
FIN[f,10] <- 0 #no divergence at y=0
FIN[f,6] <- 0  #no inbreeding at y=0
FIN[f,14] <- calcyo$FST
FIN[f,15] <- calcyo$FIS
}
FIN[f,11] = rr   #add replicate number
FIN[f,12] = r    #add parameter set number
if(y == 0){
numboff = 0
}
FIN[f,13] = numboff
params = parameters[rep(r, nrow(FIN)),]
out = cbind(FIN,params)
colnames(out) = c("year", "popsize", "propmig", "He", "Ho", "Fis", "nadults", "sxratio", "nmig", "Fst", "replicate", "parameterset", "numboff", "FstVSource", "FisVSource", "deltaK", "propMigSNPs", "Ho_allSNPs",
"k", "nSNP", "miggy", "LBhet", "maxage", "broodsize", "maturity", "years", "r0", "ratemort", "nSNP.mig", "nSNP.cons")
loc.pos
remove(alive, adults, data, FIN, fstdata, genotype, locus, params, popident,
freqs, geno, HE, het, het.expected, het.observed, HO, homozygous, loc.pos)
View(fstyo)
remove(fstyo)
setwd("C:/Users/ginab/Box/New Computer/Auburn/Data/ComplexModel_ABM/ABM_sep2022")
directory = getwd()
outdir = paste(directory, "/Output/", sep = "")   #  outdir = paste("C:/Users/ginab/Box/New Computer/Auburn/Data/ComplexModel_ABM", "/Output_local/", sep = "")
#set working directory, import packages, source functions,
setwd(paste(directory,"/Source/", sep = '')) #set temp working directory
'%NOTin%' <- Negate(`%in%`) #this defines the not in function so that I can select identities that are not defined by something (see RandomDeaths.R for an example)
library(hierfstat)   #need this for FST analysis in Analyze.R
library(hierfstat)   #need this for FST analysis in Analyze.R
#library()
library(reshape2)   #commented out 10/4/22 cuz I was getting pissed. I think this is just for plotting
library(adegenet)   #commented out 10/4/22 cuz I was getting pissed. I think this is just for plotting
library(scales) #may need this for plotting, this allows transparency in colors for overlapping lines
library(matrixStats) #need this for colCount and rowCount in ReproSuc.R
library(hierfstat)   #need this for FST analysis in Analyze.R
library(tidyr)       #need this for FST analysis in Analyze.R
library(gtools)      #commented out 10/4/22 cuz I was getting pissed. I think this is just for plotting
'%NOTin%' <- Negate(`%in%`) #this defines the not in function so that I can select identities that are not defined by something (see RandomDeaths.R for an example)
#source functions
source(paste(getwd(), "/RunModel.R", sep = ''))
source(paste(getwd(), "/AgeUp.R", sep = ''))
source(paste(getwd(), "/AgeDeath.R", sep = ''))
source(paste(getwd(), "/FitnessDeath.R", sep = ''))
source(paste(getwd(), "/Migrate.R", sep = ''))
source(paste(getwd(), "/MateChoice.R", sep = ''))
source(paste(getwd(), "/PopSizeNext.R", sep = ''))
source(paste(getwd(), "/Breed.R", sep = ''))
source(paste(getwd(), "/Analyze.R", sep = ''))
source(paste(getwd(), "/Plot.R", sep = ''))       #on/off switch
source(paste(getwd(), "/Plot2.R", sep = ''))       #on/off switch
source(paste(getwd(), "/RepSucc.R", sep = ''))
is.wholenumber <-
function(x, tol = .Machine$double.eps^0.5)  abs(x - round(x)) < tol
k.V           = 100
nSNP.V        = 10
miggy.V       = c(0,"a","b","c")  #"a"=one mig per gen, "b"=1xof50@175, "c"=3xpf25@175|201|225  #migration parameter type
LBhet.V       = 0.45 #c(0.1, 0.45, 0.8) #lowerbound limit  #c(0.4, 0.6) #c(0.8, 0.9)   #THINK ABOUT THE BEST WAY TO SET THIS UP -- either give the values for lower bound and then in RunModel, +1 for upper bound. or change the lower and upper depending on the run
maxage.V      = 9     #low ages dont work              #maximum age individuals can be; add one at first, so they will die at 4, start at -1
broodsize.V   = 2     #this is now the MAX brood size, aka max fecundity   #REMOVED##c(0:2)              #aka fecundity, remember that this is typically not constant in life; potentially Poisson distribution
maturity.V    = 1                   #age indv becomes reproductively mature
years.V       = 35
r0.V          = 1 #c(1, .8, 1.2) #0.1 #c(0.1, 0.2, 0.5)                 #per capita growth rate #1 is stable, <1 is decreasing, >1 is increasing
ratemort.V    = 1/(maxage.V*2) ###0.2225 #??##(1/(maxage.V+2))      #proportion of adults that die each year --CHECK WITH JANNA WHERE THIS NUMBER CAME FROM; current value of .2225 is from Waser and Jones 1991
nSNP.mig.V    = 10
nSNP.cons.V   = 0        #number of conserved alleles within species -- used to track mutation
#generate list of parameter combinations
parameters = expand.grid(k.V, nSNP.V, miggy.V, LBhet.V, maxage.V, broodsize.V, maturity.V, years.V, r0.V, ratemort.V, nSNP.mig.V, nSNP.cons.V)
colnames(parameters) = c("k", "nSNP", "miggy", "LBhet", "maxage", "broodsize", "maturity", "years", "r0", "ratemort", "nSNP.mig", "nSNP.cons")
write.table(parameters, paste(directory, "/Output/parameters__proj___group_.csv", sep=""), sep=",", col.names=TRUE, append=FALSE, quote=FALSE, row.names=FALSE)
#clean up, remember that these are still available in parameters
remove(k.V, nSNP.V, miggy.V, LBhet.V, maxage.V, broodsize.V, maturity.V, years.V, r0.V, ratemort.V, nSNP.mig.V, nSNP.cons.V)
replicates    = 1 #20 #5 #10
plotit        = 0    #1=yes, 0=no
plotit2       = 0    #1=yes, 0=no
mutate        = 1    #1=yes, 0=no   #average mammalian genome mutation rate is 2.2 x 10^-9 per base pair per year, https://doi.org/10.1073/pnas.022629899
#krats = 2844.77 MB = 2844770000 bp x 2.2*10-9  = 6.258494 === does this matter here???
#bannertailed 0.0081 mutants/generation/locus, in Busch, Waser, and DeWoody 2007 doi: 10.1111/j.1365-294X.2007.03283.x.
mu            = 0.001  #mutation rate
styr          = 100 #year to start pop decline
nwk           = 100 #pop size after decline -- probs makes sense to keep these even in vary decline years and decline rate. should end @ same pt for all pop sizes
drp           = 10  #number of years for drop from k to nwk
dur           = 40  #duration of small pop size before pop growth
edyr          = styr+drp #150 #year to end pop decline, first year at low pop size (nwk)
s             = 5000 #(k.V*5) #size of source pop
r             = 1
#run model iterating over parameters
theEND = NULL
repEND = NULL
finalPOP = NULL
FINAL = NULL
REP   = NULL
POP   = NULL
k             = parameters$k[r]
#REMOVED###allele        = parameters$allele[r]
nSNP          = parameters$nSNP[r]
miggy         = parameters$miggy[r]
LBhet         = parameters$LBhet[r]
nMicro        = parameters$nMicro[r]
#REMOVED###sex           = parameters$sex[r]
maxage        = parameters$maxage[r]
broodsize     = parameters$broodsize[r]
#REMOVED###sexratio      = parameters$sexratio[r]
maturity      = parameters$maturity[r]
years         = parameters$years[r]
r0            = parameters$r0[r]
ratemort      = parameters$ratemort[r]
nSNP.mig      = parameters$nSNP.mig[r]                   #number of special alleles for migrants -- these are ADDITIONAL alleles, migrants = 1, orig pop = 0, this will be easier to track than a random value
nSNP.cons     = parameters$nSNP.cons[r]                  #number of conserved alleles
#initialize population
pop = matrix(nrow=k, ncol=12)            #each individual gets its own row.. matrix > dataframe -- "ncol = 7 + (nloci)*2
colnames(pop) <- c("id", "mom", "dad", "age", "sex", "n offspring", "n adult offspring", "alive", "gen born", "gen died", "relative fitness", "prop migrant SNPs") #just to give a better understanding of what these variables are, set names
pop[,1] = seq(1,k,1)                    #each individual has unique ID name; sequence starting at 1, through k, with each 1 interation
pop[,2:3] = 0                            #at this point, we are putting all equal to zero because this is the initial generation and we dont know parents
#pop[,2] = rep(0,k)                      #mom id - later will not be 0, this is useful for debugging #saying replicate 0 100 times
#pop[,3] = rep(0,k)                      #dad id - later will not be 0, this is useful for debugging
pop[,4] = rpois(k,maturity)-1  ##sample(seq(0,maxage,1),k,replace=T)-1   #set age between 0 and 4 and subtract 1 because we add one at the first generation #FOR UNIFORM DIST: dunif(k, min =0, max = maturity, log = FALSE)-1
pop[,5] = sample(c(0,1),k,replace=T)    #each individual assigned male (1) or female (0) #sample from zero k times, with replacements. aka set sex
pop[,6] = NA #this will be for number of times as a parent  #REMOVED###sample(c(0,1),k,replace=T)    #set allele 1 as either A=1 or a=0
pop[,7] = NA #this will be for number of times offspring survive to maturity   #REMOVED###sample(c(0,1),k,replace=T)    #set allele 2 as either A=1 or a=0
pop[,8] = 1                             #alive or dead? alive = 1, dead = 0
pop[,9] = 0                             #generation born
pop[,10] = 0                            #generation died
pop[,11] = NA                            #relative fitness #at this point, we are putting all equal to zero because this is the initial generation
pop[,12] = 0                            #proportion of migrant SNPs - initial pop will all be 0
sz = k #to keep track of the number of indv for ID'ing later
sz_col = ncol(pop)
#generate SNPs for the starting pop -- taken from Janna's Captive breeding IBM
popgen = matrix(nrow=k, ncol=nSNP*2)
columns = seq(1,(nSNP*2),2)
for(l in 1:nSNP){
p = sample(seq(from=0.4, to=0.6, by=0.01),1) ##0.5 #sample(seq(from=0, to=1, by=0.01), 1)
#create pool of genotypes in HWE
pool = c(rep(0, round(k*p*p, 0)),                                      #homozygous p*p
rep(1, round(k*(1-p)*(1-p), 0)),                              #homozygous (1-p)*(1-p)
rep(2, k-(round(k*p*p, 0)+(round(k*(1-p)*(1-p), 0))))         #heterozygous
)
gtype = sample(pool, k, replace = FALSE)
for(kk in 1:k){
if(gtype[kk]==0){                 #homo (0,0)
popgen[kk,columns[l]]   = 0
popgen[kk,columns[l]+1] = 0
next
}else if(gtype[kk]==1){           #hetero (0,1)
popgen[kk,columns[l]]   = 0
popgen[kk,columns[l]+1] = 1
}else{                            #homo (1,1)
popgen[kk,columns[l]]   = 1
popgen[kk,columns[l]+1] = 1
}
}
#for(qq in 1:ncol(popgen)){colnames(popgen[qq])<-c("SNP",qq)} #couldnt get this to work - 12/14/22 - issue was when merging dead and pop but wont even hold genotypes anymore
#colnames(popgen) <- c('SNP', name)
pool = NULL
#add genotypes to pop matrix
}
het <- matrix(nrow=nrow(popgen), ncol=1)
for(g in 1:nrow(popgen)){
w <- sum(popgen[g ,seq(1,ncol(popgen),2)]!=popgen[g,seq(2,ncol(popgen),2)])/(ncol(popgen)/2)
het[g,1] <- w
} #note to add the other SNPs in here if wanted
pop[,11] <- het
#create migrant and nonmigrant unique SNPs
popSNPs = matrix(nrow=k, ncol=nSNP.mig*2)
columnsb = seq(1,(nSNP.mig*2),2)
for(b in 1:nrow(popSNPs)){    #set up similar to above in case change the sequence or format later
popSNPs[b,] = 0
}
#REMOVE4EVOLUTION##focalpop <- cbind(pop, popgen, popSNPs, conSNPs)   ##??not sure why, but not binding correctly???
focalpop <- cbind(pop, popgen, popSNPs)
pop <- focalpop
#clean up
remove(popgen, popSNPs, het, b, g, w, columns, columnsb, gtype, kk, l, pool) #focalpop, conSNPs
#initialize source population
source = matrix(nrow=s, ncol=12)            #each individual gets its own row.. matrix > dataframe
colnames(source) <- c("id", "mom", "dad", "age", "sex", "n offspring", "n adult offspring", "alive", "gen born", "gen died", "relative fitness", "prop migrant SNPs") #just to give a better understanding of what these variables are, set names
source[,1] = seq(-(s),-1,1)                     #each individual has unique ID name; sequence starting at -1, through -k, with each 1 interation, negative flag for source pop
source[,2:3] = -1                           #at this point, we are putting all equal to negative 1 to flag from source pop, and we dont know parents/parents arent in focal pop
source[,4] = sample(seq(0,maxage,1),s,replace=T)   #set age between 0 and 4 (source isnt aged, so dont subtract 1); consider if age 0 should be able to migrate
source[,5] = sample(c(0,1),s,replace=T)    #each individual assigned male (1) or female (0) #sample from zero k times, with replacements. aka set sex
source[,6] = NA #this will be for number of times as a parent   #REMOVED##sample(c(0,1),k,replace=T)    #set allele 1 as either A=1 or a=0
source[,7] = NA #for number of offspring that reach maturity ##REMOVED#### sample(c(0,1),k,replace=T)    #set allele 2 as either A=1 or a=0
source[,8] = 1                             #alive or dead? alive = 1, dead = 0
source[,9] = -1                            #generation born
source[,10] = 0                            #generation died
source[,11] = NA                            #relative fitness
source[,12] = 1                            #proportion of migrant SNPs - initial pop will all be 1
#generate source gentoypes
sourcegen = matrix(nrow=s, ncol=nSNP*2)
columns = seq(1,(nSNP*2),2)
for(l in 1:nSNP){
p = sample(seq(from=LBhet, to=(LBhet+0.1), by=0.01), 1)
#create pool of genotypes in HWE
pool = c(rep(0, round(s*p*p, 0)),                                      #homozygous p*p
rep(1, round(s*(1-p)*(1-p), 0)),                              #homozygous (1-p)*(1-p)
rep(2, s-(round(s*p*p, 0)+(round(s*(1-p)*(1-p), 0))))         #heterozygous
)
gtype = sample(pool, s, replace = FALSE)
for(ss in 1:s){
if(gtype[ss]==0){                 #homo (0,0)
sourcegen[ss,columns[l]]   = 0
sourcegen[ss,columns[l]+1] = 0
next
}else if(gtype[ss]==1){           #hetero (0,1)
sourcegen[ss,columns[l]]   = 0
sourcegen[ss,columns[l]+1] = 1
}else{                            #homo (1,1)
sourcegen[ss,columns[l]]   = 1
sourcegen[ss,columns[l]+1] = 1
}
}
#colnames(sourcegen) <- c('SNP', l)
#pool = NULL
#add genotypes to source matrix
}
sourcehet <- matrix(nrow=nrow(sourcegen), ncol=1)
for(j in 1:nrow(sourcegen)){
z <- sum(sourcegen[j ,seq(1,ncol(sourcegen),2)]!=sourcegen[j,seq(2,ncol(sourcegen),2)])/(ncol(sourcegen)/2)
sourcehet[j,1] <- z
} #note to add the other SNPs in here if wanted
source[,11] <- sourcehet
#create migrant and nonmigrant unique SNPs
migSNPs = matrix(nrow=s, ncol=nSNP.mig*2)
columnsd= seq(1,(nSNP.mig*2),2)
for(d in 1:nrow(migSNPs)){    #set up similar to above in case change the sequence or format later
migSNPs[d,] = 1
}
#REMOVE4EVOLUTION##source1 <- cbind(source, sourcegen, migSNPs, conSNPs)        #also doesnt work????
source1 <- cbind(source, sourcegen, migSNPs)
source <- source1
#prepare focal and source pop for Fst analysis in hierfstat (enacted in Analyze.R)
SNPS = (nSNP*2) + (nSNP.mig*2) + (nSNP.cons*2)                    #find number of SNPs
pos1 = seq(1, SNPS, 2) #allele 1 positions, aka odd values
pos2 = pos1+1
fstinit <- focalpop[, -c(ncol(focalpop)-(SNPS):ncol(focalpop))]               #grab SNPs
fstinit[fstinit[,]==0] <-2                                                    #change 0s to 2s
fstinit[,pos1] <- as.numeric(paste(fstinit[,pos1], fstinit[,pos2], sep=""))                     #merge SNPs
fstinit <- fstinit[,-c(pos2)]                                                 #remove single pos2 SNPs
initident <- matrix(nrow=nrow(fstinit), ncol=1)                               #add pop identifier
initident[,1] = 0
fstinit <- cbind(initident,fstinit)                                           #merge identifier and genotypes
fstsource <- source1[, -c(ncol(source1)-(SNPS):ncol(source1))]                    #grab SNPs
fstsource[fstsource[,]==0] <-2                                                    #change 0s to 2s
fstsource[,pos1] <- as.numeric(paste(fstsource[,pos1], fstsource[,pos2], sep=""))                     #merge SNPs
fstsource <- fstsource[,-c(pos2)]                                                 #remove single pos2 SNPs
sourceident <- matrix(nrow=nrow(fstsource), ncol=1)                               #add pop identifier
sourceident[,1] = -1
fstsource <- cbind(sourceident,fstsource)                                         #merge identifier and genotypes
remove(source1, focalpop, initident, sourceident)
#clean up
remove(sourcegen, pool, migSNPs, l, d, ss, sourcehet, gtype, columns, columnsd, z, j) #currently holding p if needed
#create for loop for each time step
for(y in 0:years){
if(y != 0){
pop = AgeUp(pop)                        #age pop + 1 year
pop = FitnessDeath(pop, maturity, ratemort, y)                #kill indv
#pop = DeathByAge(pop, maxage)           #age-dependent mortality
if(sum(pop[,8]) <= 10){
print(paste("Crash @ FitnessDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
FINAL = rbind(FINAL, out[1,])
break
}
#REMOVE##tttt = Stochastic(pop, stoch, k, numboff, styr, endyr, nwk, dur, y, years, r0, parameters, r)
#REMOVE##pop = tttt[[1]]
#REMOVE##k = tttt[[2]]
#REMEMBER THE NEED TO TRACK NEW K !!!
#pop = RandomDeath(pop)                  #random mortality
tt = Migrate(pop, source, y, miggy)             #subpop migration
pop = tt[[1]]
mig = tt[[2]]  #0
sz = sz + mig #may need to edit since dead are not being removed from pop
source = tt[[3]]
if(sum(pop[,8]) <= 4){
print(paste("Population crash @ MateChoice, less than 4 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
FINAL = rbind(FINAL, out[1,])
break
}
pairs = MateChoice(pop, sex, maturity)
if(is.null(pairs)==TRUE){
print(paste("skipping pop size next, breed due to no parents"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
FINAL = rbind(FINAL, out[1,])
break  #consider whether this should be next or break
}
#REMOVED## if(sum(pairs[,1]) < 0 | sum(pairs[,2]) < 0){
#REMOVED##   print(paste("Only migrants available as parents"))
#REMOVED##   break
#REMOVED## }
pp = PopSizeNext(pop, k, r0, maturity, y, styr, endyr, nwk, dur, parameters, r, K) #ADD NEW K MODIFIER
numboff = pp[[1]]
K = pp[[2]]
if(numboff >= 1){
ttt = Breed(pop, pairs, numboff, k, sz, nSNP, nSNP.mig, broodsize, y, mu, mutate, nSNP.cons, pos1, pos2) #still needs work
pop = ttt[[1]]
bb = ttt[[2]]
sz = sz + bb
}else if(numboff <= 0){
print(paste("No new babies, skip breed"))
#next
}
pop = AgeDeath(pop, maxage, ratemort, y)                #kill indv based on age
if(sum(pop[,8]) <= 10){
print(paste("CRASH @ AgeDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2) #remember to feed to all Analyze functions!
FINAL = rbind(FINAL, out[1,])
break
}
print(paste("DONE!", y, "param", r, "rep", rr))
#clean up by removing dead indv every 25 years
if(is.wholenumber(y/25)==TRUE){
print(paste("Cleaning up dead!"))
dead <- pop[pop[,8]==0,,drop=FALSE]
deadindv <- dead[, c(1:sz_col)]  #remove indv genotypes
write.table(deadindv, paste(directory, "/Output/dead.csv", sep=""), sep=",", col.names=FALSE, append=TRUE, quote=FALSE, row.names=FALSE)
#write.matrix(deadindv, paste(directory, "/Output/dead.csv", sep=""), sep=",") #, col.names=TRUE, append=TRUE, quote=FALSE, row.names=FALSE
pop <- pop[pop[,8]==1,,drop=FALSE] #make new pop object with only alive indv
remove(dead, deadindv)
}
#   pop <- pop[pop[,8]==1,, drop=FALSE] #remove dead indv -- put in place for Evolution on 6/7/22 -- this will speed it up!!
#y <- y+1
}
if(y == 0){
K = k
}
#analyze each replicate
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
#out[1,1] = y
#out[1,ncol(out)+1] = rr
FINAL = rbind(FINAL, out[1,])
#will need to track K in Analyze for years during the pop drop
#consider if something needs to be changed in Analyze for the different death types or if that needs tracked at all.
}
rr=1
#create for loop for each time step
for(y in 0:years){
if(y != 0){
pop = AgeUp(pop)                        #age pop + 1 year
pop = FitnessDeath(pop, maturity, ratemort, y)                #kill indv
#pop = DeathByAge(pop, maxage)           #age-dependent mortality
if(sum(pop[,8]) <= 10){
print(paste("Crash @ FitnessDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
FINAL = rbind(FINAL, out[1,])
break
}
#REMOVE##tttt = Stochastic(pop, stoch, k, numboff, styr, endyr, nwk, dur, y, years, r0, parameters, r)
#REMOVE##pop = tttt[[1]]
#REMOVE##k = tttt[[2]]
#REMEMBER THE NEED TO TRACK NEW K !!!
#pop = RandomDeath(pop)                  #random mortality
tt = Migrate(pop, source, y, miggy)             #subpop migration
pop = tt[[1]]
mig = tt[[2]]  #0
sz = sz + mig #may need to edit since dead are not being removed from pop
source = tt[[3]]
if(sum(pop[,8]) <= 4){
print(paste("Population crash @ MateChoice, less than 4 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
FINAL = rbind(FINAL, out[1,])
break
}
pairs = MateChoice(pop, sex, maturity)
if(is.null(pairs)==TRUE){
print(paste("skipping pop size next, breed due to no parents"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
FINAL = rbind(FINAL, out[1,])
break  #consider whether this should be next or break
}
#REMOVED## if(sum(pairs[,1]) < 0 | sum(pairs[,2]) < 0){
#REMOVED##   print(paste("Only migrants available as parents"))
#REMOVED##   break
#REMOVED## }
pp = PopSizeNext(pop, k, r0, maturity, y, styr, endyr, nwk, dur, parameters, r, K) #ADD NEW K MODIFIER
numboff = pp[[1]]
K = pp[[2]]
if(numboff >= 1){
ttt = Breed(pop, pairs, numboff, k, sz, nSNP, nSNP.mig, broodsize, y, mu, mutate, nSNP.cons, pos1, pos2) #still needs work
pop = ttt[[1]]
bb = ttt[[2]]
sz = sz + bb
}else if(numboff <= 0){
print(paste("No new babies, skip breed"))
#next
}
pop = AgeDeath(pop, maxage, ratemort, y)                #kill indv based on age
if(sum(pop[,8]) <= 10){
print(paste("CRASH @ AgeDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2) #remember to feed to all Analyze functions!
FINAL = rbind(FINAL, out[1,])
break
}
print(paste("DONE!", y, "param", r, "rep", rr))
#clean up by removing dead indv every 25 years
if(is.wholenumber(y/25)==TRUE){
print(paste("Cleaning up dead!"))
dead <- pop[pop[,8]==0,,drop=FALSE]
deadindv <- dead[, c(1:sz_col)]  #remove indv genotypes
write.table(deadindv, paste(directory, "/Output/dead.csv", sep=""), sep=",", col.names=FALSE, append=TRUE, quote=FALSE, row.names=FALSE)
#write.matrix(deadindv, paste(directory, "/Output/dead.csv", sep=""), sep=",") #, col.names=TRUE, append=TRUE, quote=FALSE, row.names=FALSE
pop <- pop[pop[,8]==1,,drop=FALSE] #make new pop object with only alive indv
remove(dead, deadindv)
}
#   pop <- pop[pop[,8]==1,, drop=FALSE] #remove dead indv -- put in place for Evolution on 6/7/22 -- this will speed it up!!
#y <- y+1
}
if(y == 0){
K = k
}
#analyze each replicate
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2)
#out[1,1] = y
#out[1,ncol(out)+1] = rr
FINAL = rbind(FINAL, out[1,])
#will need to track K in Analyze for years during the pop drop
#consider if something needs to be changed in Analyze for the different death types or if that needs tracked at all.
}
#read in dead indv
died = read.table(paste(directory, "/Output/dead.csv", sep=""), header=F, sep=",")
indv = pop[, c(1:sz_col)]  #remove indv genotypes
colnames(died) = colnames(indv)
pop_indv = rbind(indv,died) #add dead to pop for repsucc calculations
remove(pop, indv, died)
#THIS IS WHERE I CALC RRS using pop data
aa = RepSucc(pop_indv, maturity, years, rr, r)
pop_indv = aa[[1]]  #this is the final pop with all indv and all indv data
rep = aa[[2]]
REP = rbind(REP, rep)
print(paste("REPLICATE", rr, "OF PARAM", r, "DONE!"))
