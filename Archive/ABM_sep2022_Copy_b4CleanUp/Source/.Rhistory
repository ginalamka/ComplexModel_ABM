initident[,1] = 0
fstinit <- cbind(initident,fstinit)                                           #merge identifier and genotypes
fstsource <- source1[, -c(ncol(source1)-(SNPS):ncol(source1))]                    #grab SNPs
fstsource[fstsource[,]==0] <-2                                                    #change 0s to 2s
fstsource[,pos1] <- as.numeric(paste(fstsource[,pos1], fstsource[,pos2], sep=""))                     #merge SNPs
fstsource <- fstsource[,-c(pos2)]                                                 #remove single pos2 SNPs
sourceident <- matrix(nrow=nrow(fstsource), ncol=1)                               #add pop identifier
sourceident[,1] = -1
fstsource <- cbind(sourceident,fstsource)                                         #merge identifier and genotypes
remove(source1, focalpop, initident, sourceident)
#write starting source to table
#### REMOVED### write.table(source, paste(directory, "/Output/source", r, ".csv", sep=""), sep=",", col.names=T, row.names=F)
#clean up
remove(sourcegen, pool, migSNPs, l, d, ss, sourcehet, gtype, columns, columnsd, z, j) #currently holding p if needed
#REMOVE4EVOLUTION##remove( columnsb, columnsc,  columnse, c)
y=1
pop = AgeUp(pop)                        #age pop + 1 year
pop = FitnessDeath(pop, maturity, y)                #kill indv
#pop = DeathByAge(pop, maxage)           #age-dependent mortality
if(sum(pop[,8]) <= 10){
print(paste("Crash @ FitnessDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2, prj, grp)
FINAL = rbind(FINAL, out[1,])
break
}
#pop = RandomDeath(pop)                  #random mortality
tt = Migrate(pop, source, y, miggy, styr, edyr, dur)             #subpop migration
pop = tt[[1]]
mig = tt[[2]]  #0
sz = sz + mig #may need to edit since dead are not being removed from pop
source = tt[[3]]
if(sum(pop[,8]) <= 4){
print(paste("Population crash @ MateChoice, less than 4 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2, prj, grp)
FINAL = rbind(FINAL, out[1,])
break
}
pairs = MateChoice(pop, sex, maturity, allee, matemigs)
if(is.null(pairs)==TRUE){
print(paste("skipping pop size next, breed due to no parents"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2, prj, grp)
FINAL = rbind(FINAL, out[1,])
break  #consider whether this should be next or break
}
#REMOVED## if(sum(pairs[,1]) < 0 | sum(pairs[,2]) < 0){
#REMOVED##   print(paste("Only migrants available as parents"))
#REMOVED##   break
#REMOVED## }
pp = PopSizeNext(pop, k, r0, maturity, y, styr, edyr, nwk, dur, parameters, r, K) #ADD NEW K MODIFIER
numboff = pp[[1]]
K = pp[[2]]
if(numboff >= 1){
ttt = Breed(pop, pairs, numboff, k, sz, nSNP, nSNP.mig, broodsize, y, mu, mutate, nSNP.cons, pos1, pos2, rr, r, prj, grp, matemigs) #still needs work
pop = ttt[[1]]
bb = ttt[[2]]
sz = sz + bb
}else if(numboff <= 0){
print(paste("No new babies, skip breed"))
#still fill out Ne count table
{
NE = matrix(nrow=1, ncol=12)
colnames(NE) <- c("year", "eff_mom", "eff_dad", "nbabies", "naliveadults", "possible_mom", "possible_dad", "eff_mig", "parameterset", "replicate", "project", "group") #just to give a better understanding of what these variables are, set names
NE[1,1] = y                             #grab year
NE[1,2] = 0                             #grab n unique effective moms
NE[1,3] = 0                             #grab n unique effective dads
NE[1,4] = 0                             #grab n babies
alive = pop[pop[,8]==1,,drop=FALSE]
adult = alive[alive[,4]!=0,,drop=FALSE]
adult_f = adult[adult[,5]==0,,drop=FALSE]
adult_m = adult[adult[,5]==1,,drop=FALSE]
NE[1,5] = nrow(adult)                   #grab n alive adults
NE[1,6] = nrow(adult_f)                 #grab n possible moms
NE[1,7] = nrow(adult_m)                 #grab n possible dads
NE[1,8] = 0                             #grab number of migrant parents
NE[1,9] = r
NE[1,10] = rr
NE[1,11] = prj
NE[1,12] = grp
remove(alive, adult, adult_f, adult_m)
if(isTRUE(y == 1 && r == 1 && rr == 1)){
write.table(NE, paste(directory, "/Output/Ne_counts.csv", sep=""), sep=",", col.names=TRUE, append=FALSE, quote=FALSE, row.names=FALSE)
}else{
write.table(NE, paste(directory, "/Output/Ne_counts.csv", sep=""), sep=",", col.names=FALSE, append=TRUE, quote=FALSE, row.names=FALSE)
}
}
#next
}
pop = AgeDeath(pop, maxage, y)                #kill indv based on age
if(sum(pop[,8]) <= 10){
print(paste("CRASH @ AgeDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2, prj, grp) #remember to feed to all Analyze functions!
FINAL = rbind(FINAL, out[1,])
break
}
print(paste("DONE!", y, "param", r, "rep", rr))
#clean up by removing dead indv every 25 years
if(is.wholenumber(y/25)==TRUE){
print(paste("Cleaning up dead!"))
dead <- pop[pop[,8]==0,,drop=FALSE]
deadindv <- dead[, c(1:sz_col)]  #remove indv genotypes
if(y==25){
write.table(deadindv, paste(directory, "/Output/dead.csv", sep=""), sep=",", col.names=FALSE, append=FALSE, quote=FALSE, row.names=FALSE) #create new dead for this parameter set
}else{
write.table(deadindv, paste(directory, "/Output/dead.csv", sep=""), sep=",", col.names=FALSE, append=TRUE, quote=FALSE, row.names=FALSE)
}
#write.matrix(deadindv, paste(directory, "/Output/dead.csv", sep=""), sep=",") #, col.names=TRUE, append=TRUE, quote=FALSE, row.names=FALSE
#note if pop crashes before 25 years, dead will be from prev run -- but does it matter since they cant be analyzed anyways?
pop <- pop[pop[,8]==1,,drop=FALSE] #make new pop object with only alive indv
remove(dead, deadindv)
}
#y <- y+1
}
if(y == 0){
K = k
}
#analyze each replicate
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2, prj, grp)
#out[1,1] = y
#out[1,ncol(out)+1] = rr
FINAL = rbind(FINAL, out[1,])
y=2
pop = AgeUp(pop)                        #age pop + 1 year
pop = FitnessDeath(pop, maturity, y)                #kill indv
#pop = DeathByAge(pop, maxage)           #age-dependent mortality
if(sum(pop[,8]) <= 10){
print(paste("Crash @ FitnessDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2, prj, grp)
FINAL = rbind(FINAL, out[1,])
break
}
#pop = RandomDeath(pop)                  #random mortality
tt = Migrate(pop, source, y, miggy, styr, edyr, dur)             #subpop migration
pop = tt[[1]]
mig = tt[[2]]  #0
sz = sz + mig #may need to edit since dead are not being removed from pop
source = tt[[3]]
if(sum(pop[,8]) <= 4){
print(paste("Population crash @ MateChoice, less than 4 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2, prj, grp)
FINAL = rbind(FINAL, out[1,])
break
}
pairs = MateChoice(pop, sex, maturity, allee, matemigs)
if(is.null(pairs)==TRUE){
print(paste("skipping pop size next, breed due to no parents"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2, prj, grp)
FINAL = rbind(FINAL, out[1,])
break  #consider whether this should be next or break
}
#REMOVED## if(sum(pairs[,1]) < 0 | sum(pairs[,2]) < 0){
#REMOVED##   print(paste("Only migrants available as parents"))
#REMOVED##   break
#REMOVED## }
pp = PopSizeNext(pop, k, r0, maturity, y, styr, edyr, nwk, dur, parameters, r, K) #ADD NEW K MODIFIER
numboff = pp[[1]]
K = pp[[2]]
is.null(nrow(pairs))==TRUE
nrow(pairs)>= numboff
nrow(pairs)
migparents = pairs[pairs[,3]==2,,drop=FALSE]
nonmigrents = pairs[pairs[,3]!=2,,drop=FALSE]
numboff-nrow(migparents)
nrow(migparents)
pairings = sample(1:nrow(nonmigrents), numboff-nrow(migparents), replace = F, prob = NULL)
parents <- nonmigrents[pairings,,drop=FALSE]
migparents
parents <- rbind(migparents,parents)
remove(migparents, nonmigrents)
#generate fecundity for each set of parents
fecundity = sample(seq(1,broodsize,1),nrow(parents),replace=T, prob = NULL)
parents[,3] = fecundity       #cbind(parents, fecundity)
nbabes = sum(parents[,3])
TEMP = NULL
for(n in 1:nrow(parents)){
t = parents[n, ,drop=FALSE] #need drop = false or else will lose
f = t[1,3]       #use this to store the number of offspring per parent set
t[1,3] = 1       #use this as a check for later on to make sure this loop works
while(f > 0){
TEMP = rbind(TEMP, t)
f = f - 1
if(f==0){       #another check so it doesnt get stuck in this loop
break
}
}
}
parents = TEMP
remove(TEMP)
#generate unique IDS
##REMOVED### newid = seq(from = (max(pop[,1])*10) +1, to = (max(pop[,1])*10) + nrow(parents), by = 1)
SZ = seq(from = sz+1, to = sz + nrow(parents), by =1)
babies = matrix(nrow=nrow(parents), ncol=12) #make new matrix for offspring
colnames(babies) <- c("id", "mom", "dad", "age", "sex", "n offspring", "n adult offspring", "alive", "gen born", "gen died", "relative fitness", "prop migrant SNPs")
babies[,1] = SZ                   #each individual has unique ID name; sequence starting at 1, through k, with each 1 iteration
babies[,2] = parents[,1]
babies[,3] = parents[,2]
babies[,4] = 0    #first of the year - consider if these should be 0 or -1
babies[,5] = sample(c(0,1),nrow(babies),replace=T)    #each individual assigned male (1) or female (0) #sample from zero nrow times, with replacements. aka set sex
babies[,6] = NA #REMOVED##0                #####sample(c(0,1),nrow(babies),replace=T)    #set allele 1 as either A=1 or a=0
babies[,7] = NA                 #####sample(c(0,1),nrow(babies),replace=T)    #set allele 2 as either A=1 or a=0
babies[,8] = 1      #make every baby alive
babies[,9] = y  #MUST feed y to function   #generation born
babies[,10] = 0      #generation died
babies[,11] = NA      #relative fitness
babies[,12] = NA                            #proportion of migrant SNPs - initial pop will all be 1
nrow(babies)
migbbys = babies[babies[,2]<=0|babies[,3]<=0,,drop=FALSE]
nrow(migbbys)
nrow(migbbys) > numboff
keep = migbbys[,1]
length(keep)
length(keep)>=1
BABIES = babies
nrow(babies)-numboff
rm = sample(BABIES[,1], nrow(babies)-numboff, replace = FALSE, prob = NULL) #remove babies so that you generate only the number needed
BABIES = BABIES[-which(BABIES[,1]%in%rm), , drop=FALSE]
migbbys
BABIES
babies <- rbind(migbbys, BABIES)
babies
bb = nrow(babies)
remove(rm)
#rename babies so count doesnt get messed up
babies =  as.matrix(babies)
babies[,1] = seq(from = (sz+1), to = (sz+bb), by = 1)
#genotypes
#prep parent genotypes
f = babies[,2]
m = babies[,3]
fem = pop[-which(pop[,1]%NOTin%f), , drop = FALSE]
mal = pop[-which(pop[,1]%NOTin%m), , drop = FALSE]
if(nrow(mal) == 0){
print(paste("can't generate father genotypes"))
break
}
if(nrow(fem)==0){
print(paste("can't generate mother genotypes"))
break
}
SNPS = (nSNP*2) + (nSNP.mig*2) + (nSNP.cons*2)
babygeno = matrix(nrow=bb, ncol=SNPS)
#loop over each row in babies
for(i in 1:nrow(babies)){
mom = babies[i,2]
dad = babies[i,3]
mm = pop[pop[,1] == mom, , drop=FALSE]
dd = pop[pop[,1] == dad, , drop=FALSE]
momgeno = mm[, -c(ncol(mm)-(SNPS):ncol(mm))]
dadgeno = dd[, -c(ncol(dd)-(SNPS):ncol(dd))]
#from each snp (2 columns), grab 1 of mom's alleles
momgeno.s = pos1 + (sample(0:1, length(pos1), replace=T)) #list of values to pull, exactly 1 allele (here it is index number) from each set of two columns
momgeno.s = momgeno[momgeno.s] #these are now the actual alleles
#from each snp (2 columns), grab 1 of dad's alleles
dadgeno.s = pos1 + (sample(0:1, length(pos1), replace=T)) #list of values to pull, exactly 1 allele (here it is index number) from each set of two columns
dadgeno.s = dadgeno[dadgeno.s] #these are now the actual alleles
#now need to interweve mom and dad's genos so that the loci are jumbled
babygeno[i,pos1] = momgeno.s
babygeno[i,pos2] = dadgeno.s
}
if(mutate == 1){  #if mutate is turned "on"
drift <- babygeno[,1:(nSNP*2),drop=FALSE]
miggeno <- babygeno[,(nSNP*2+1):SNPS,drop=FALSE]
for(x in 1:nrow(drift)){    #iterate over indv
mut <- sample(c("Y","N"), nSNP*2, replace = TRUE, prob = c(mu,1-mu))   #SNPS if for all SNPs, nSNP for only drift SNPs
init <- drift[x,] ## keep track of the 'ancestral' state within this individual
drift[x, which(mut=='Y' & drift[x,]==1)] <- 0
## if a SNP is supposed to mutate, but its ancestral state was '1' (i.e., it's already been mutated in the previous line),
## then set its index in mut to 'N', indicating that no further mutations should happen in this round.
mut[which(mut=='Y' & init==1)] <- 'N'
drift[x, which(mut=='Y' & drift[x,]==0)] <- 1
}
babygeno <- cbind(drift, miggeno)
}else{
print(paste("no mutation"))
}
#calculate relative fitness (heterozygosity)
het <- matrix(nrow=nrow(babygeno), ncol=1)
for(g in 1:nrow(babygeno)){
w <- sum(babygeno[g ,seq(1,ncol(babygeno),2)]!=babygeno[g,seq(2,ncol(babygeno),2)])/(ncol(babygeno)/2)
het[g,1] <- w
}
babies[,11] <- het
#calculate proportion of migrant SNPs
migrantgen <- babygeno[, -c(ncol(babygeno)-(nSNP.mig*2):ncol(babygeno))]
migrantgen <- matrix(unlist(migrantgen), nrow = bb, ncol = nSNP.mig*2)
mSNP <- matrix(nrow = bb, ncol = 1)
for(q in 1:nrow(migrantgen)){
ww <- sum(migrantgen[q,])/ncol(migrantgen)
mSNP[q,1] <- ww
}
babies[,12] <- mSNP
NE = matrix(nrow=1, ncol=12)
colnames(NE) <- c("year", "eff_mom", "eff_dad", "nbabies", "naliveadults", "possible_mom", "possible_dad", "eff_mig", "parameterset", "replicate", "project", "group") #just to give a better understanding of what these variables are, set names
NE[1,1] = y                             #grab year
NE[1,2] = length(unique(babies[,2]))    #grab n unique effective moms
NE[1,3] = length(unique(babies[,3]))    #grab n unique effective dads
NE[1,4] = nrow(babies)                  #grab n babies
alive = pop[pop[,8]==1,,drop=FALSE]
adult = alive[alive[,4]!=0,,drop=FALSE]
adult_f = adult[adult[,5]==0,,drop=FALSE]
adult_m = adult[adult[,5]==1,,drop=FALSE]
NE[1,5] = nrow(adult)                   #grab n alive adults
NE[1,6] = nrow(adult_f)                 #grab n possible moms
NE[1,7] = nrow(adult_m)                 #grab n possible dads
mig_f = babies[babies[,2]<=-2,,drop=FALSE]
mig_m = babies[babies[,3]<=-2,,drop=FALSE]
NE[1,8] = length(unique(mig_f[,2])) + length(unique(mig_m[,3]))    #grab number of migrant parents
NE[1,9] = r
NE[1,10] = rr
NE[1,11] = prj
NE[1,12] = grp
if(isTRUE(y == 1 && r == 1 && rr == 1)){
write.table(NE, paste(directory, "/Output/Ne_counts.csv", sep=""), sep=",", col.names=TRUE, append=FALSE, quote=FALSE, row.names=FALSE)
}else{
write.table(NE, paste(directory, "/Output/Ne_counts.csv", sep=""), sep=",", col.names=FALSE, append=TRUE, quote=FALSE, row.names=FALSE)
}
print(paste("there are", nrow(babies), "babies added to the pop"))
babies = cbind(babies, babygeno)
pop = rbind(pop, babies)
remove(babies, babygeno, dd, fem, het, mal, migrantgen, mm, mSNP, pairs, parents, pairings,
t, dadgeno, dadgeno.s, f, fecundity, momgeno, momgeno.s, mut, nbabes, SZ,
NE, alive, adult, adult_f, adult_m, mig_f, mig_m)
setwd("C:/Users/ginab/Box/New Computer/Auburn/Data/ComplexModel_ABM/ABM_sep2022")
directory = getwd()
outdir = paste(directory, "/Output/", sep = "")   #  outdir = paste("C:/Users/ginab/Box/New Computer/Auburn/Data/ComplexModel_ABM", "/Output_local/", sep = "")
source(paste(directory, "/Source/FunctionSourcer.R", sep = ''))
prj = "_proj_"
grp = "_group_"
#parameters
k.V           = 100 #1000 #c(1000, 5000, 500) #c(500, 1000, 5000, 10000)                #carrying capacity
nSNP.V        = 100 #1000  #scaleup                #number of SNPs simulated, used to track drift
miggy.V       = "b" #c(0,"a","b","c")  #"a"=one mig per gen, "b"=1xof50@175, "c"=3xpf25@175|201|225  #migration parameter type
LBhet.V       = 0.45 #c(0.45, 0.07) #c(0.1, 0.45, 0.8) #lowerbound limit for SOURCE POP  #c(0.4, 0.6) #c(0.8, 0.9)   #THINK ABOUT THE BEST WAY TO SET THIS UP -- either give the values for lower bound and then in RunModel, +1 for upper bound. or change the lower and upper depending on the run
LBp.V         = 0.07 #c(0.45, 0.07) #lowerbound limit for FOCAL POP
maxage.V      = 9 #c(15, 3) #9     #low ages dont work              #maximum age individuals can be; add one at first, so they will die at 4, start at -1
broodsize.V   = 2 #c(4, 6)  #2     #this is now the MAX brood size, aka max fecundity   #REMOVED##c(0:2)              #aka fecundity, remember that this is typically not constant in life; potentially Poisson distribution
maturity.V    = 1                   #age indv becomes reproductively mature
years.V       = 35 #350  #scaleup               #total run time; 200 year run following 50 year stabilization period
r0.V          = 1 #c(1, 0.5, 0.1)  #c(1, .8, 1.2) #0.1 #c(0.1, 0.2, 0.5)                 #per capita growth rate #0/1 is stable, <0/1 is decreasing, >0/1 is increasing - currently checking cuz r0+1 in log growth eq
nSNP.mig.V    = 10 #100                   #number of special alleles for migrants -- these are ADDITIONAL alleles, migrants = 1, orig pop = 0, this will be easier to track than a random value
nSNP.cons.V   = 0        #number of conserved alleles within species -- used to track mutation
#generate list of parameter combinations
parameters = expand.grid(k.V, nSNP.V, miggy.V, LBhet.V, LBp.V, maxage.V, broodsize.V, maturity.V, years.V, r0.V, nSNP.mig.V, nSNP.cons.V)
colnames(parameters) = c("k", "nSNP", "miggy", "LBhet", "LBp", "maxage", "broodsize", "maturity", "years", "r0", "nSNP.mig", "nSNP.cons")
write.table(parameters, paste(directory, "/Output/parameters__proj___group_.csv", sep=""), sep=",", col.names=TRUE, append=FALSE, quote=FALSE, row.names=FALSE)
#clean up, remember that these are still available in parameters
remove(k.V, nSNP.V, miggy.V, LBhet.V, LBp.V, maxage.V, broodsize.V, maturity.V, years.V, r0.V, nSNP.mig.V, nSNP.cons.V)
replicates    = 1 #20 #5 #10
allee         = 0    #1=yes, 0=no
matemigs      = 0    #1=yes, 0=no
plotit        = 0    #1=yes, 0=no
plotit2       = 0    #1=yes, 0=no
mutate        = 0    #1=yes, 0=no   #average mammalian genome mutation rate is 2.2 x 10^-9 per base pair per year, https://doi.org/10.1073/pnas.022629899
#krats = 2844.77 MB = 2844770000 bp x 2.2*10-9  = 6.258494 === does this matter here???
#bannertailed 0.0081 mutants/generation/locus, in Busch, Waser, and DeWoody 2007 doi: 10.1111/j.1365-294X.2007.03283.x.
mu            = 0.001  #mutation rate
styr          = 100 #year to start pop decline
nwk           = 300 #pop size after decline -- probs makes sense to keep these even in vary decline years and decline rate. should end @ same pt for all pop sizes
drp           = 10  #number of years for drop from k to nwk
dur           = 40  #duration of small pop size before pop growth
edyr          = styr+drp #150 #year to end pop decline, first year at low pop size (nwk)
s             = 5000 #(k.V*5) #size of source pop
r             = 1
#run model iterating over parameters
theEND = NULL
repEND = NULL
finalPOP = NULL
for(r in 1:nrow(parameters)){
ALL = RunModel(parameters, r, directory, replicates, prj, grp)
FINAL = ALL[[1]]
REP = ALL[[2]]
#POP = ALL[[2]]
####REMOVED## POP = RunModel(parameters, r, directory, replicates)
####REMOVED## write.table(POP, paste(directory, "/Output/CoverPop", r, ".csv", sep=""), sep=",", col.names=TRUE, row.names=F)
#####REMOVED##write.table(POP, paste(directory, "/Output/CoverPop.txt", sep=""), sep="\t", col.names=TRUE, row.names=F)  #use this for a .txt file, good for in a text editor. ; "/t" for macs
theEND = rbind(theEND, FINAL)
repEND = rbind(repEND, REP)
#finalPOP = rbind(finalPOP, POP)
}
for(r in 1:nrow(parameters)){
ALL = RunModel(parameters, r, directory, replicates, prj, grp)
FINAL = ALL[[1]]
REP = ALL[[2]]
#POP = ALL[[2]]
####REMOVED## POP = RunModel(parameters, r, directory, replicates)
####REMOVED## write.table(POP, paste(directory, "/Output/CoverPop", r, ".csv", sep=""), sep=",", col.names=TRUE, row.names=F)
#####REMOVED##write.table(POP, paste(directory, "/Output/CoverPop.txt", sep=""), sep="\t", col.names=TRUE, row.names=F)  #use this for a .txt file, good for in a text editor. ; "/t" for macs
theEND = rbind(theEND, FINAL)
repEND = rbind(repEND, REP)
#finalPOP = rbind(finalPOP, POP)
}
setwd("C:/Users/ginab/Box/New Computer/Auburn/Data/ComplexModel_ABM/ABM_sep2022")
directory = getwd()
outdir = paste(directory, "/Output/", sep = "")   #  outdir = paste("C:/Users/ginab/Box/New Computer/Auburn/Data/ComplexModel_ABM", "/Output_local/", sep = "")
source(paste(directory, "/Source/FunctionSourcer.R", sep = ''))
prj = "_proj_"
grp = "_group_"
#parameters
k.V           = 100 #1000 #c(1000, 5000, 500) #c(500, 1000, 5000, 10000)                #carrying capacity
nSNP.V        = 100 #1000  #scaleup                #number of SNPs simulated, used to track drift
miggy.V       = "b" #c(0,"a","b","c")  #"a"=one mig per gen, "b"=1xof50@175, "c"=3xpf25@175|201|225  #migration parameter type
LBhet.V       = 0.45 #c(0.45, 0.07) #c(0.1, 0.45, 0.8) #lowerbound limit for SOURCE POP  #c(0.4, 0.6) #c(0.8, 0.9)   #THINK ABOUT THE BEST WAY TO SET THIS UP -- either give the values for lower bound and then in RunModel, +1 for upper bound. or change the lower and upper depending on the run
LBp.V         = 0.07 #c(0.45, 0.07) #lowerbound limit for FOCAL POP
maxage.V      = 9 #c(15, 3) #9     #low ages dont work              #maximum age individuals can be; add one at first, so they will die at 4, start at -1
broodsize.V   = 2 #c(4, 6)  #2     #this is now the MAX brood size, aka max fecundity   #REMOVED##c(0:2)              #aka fecundity, remember that this is typically not constant in life; potentially Poisson distribution
maturity.V    = 1                   #age indv becomes reproductively mature
years.V       = 35 #350  #scaleup               #total run time; 200 year run following 50 year stabilization period
r0.V          = 1 #c(1, 0.5, 0.1)  #c(1, .8, 1.2) #0.1 #c(0.1, 0.2, 0.5)                 #per capita growth rate #0/1 is stable, <0/1 is decreasing, >0/1 is increasing - currently checking cuz r0+1 in log growth eq
nSNP.mig.V    = 10 #100                   #number of special alleles for migrants -- these are ADDITIONAL alleles, migrants = 1, orig pop = 0, this will be easier to track than a random value
nSNP.cons.V   = 0        #number of conserved alleles within species -- used to track mutation
#REMOVED##ratemort.V    = 1/(maxage.V*2) #note, I dont think this is used for anything anymore! ###0.2225 #??##(1/(maxage.V+2))      #proportion of adults that die each year --CHECK WITH JANNA WHERE THIS NUMBER CAME FROM; current value of .2225 is from Waser and Jones 1991
### when adding variables already marked out, don't forget to add 3 times below, on RunModel, and other functions that need the variable fed in
#potential migration rates: 1-5 indv, 5-10 indv, no migration
#generate list of parameter combinations
parameters = expand.grid(k.V, nSNP.V, miggy.V, LBhet.V, LBp.V, maxage.V, broodsize.V, maturity.V, years.V, r0.V, nSNP.mig.V, nSNP.cons.V)
colnames(parameters) = c("k", "nSNP", "miggy", "LBhet", "LBp", "maxage", "broodsize", "maturity", "years", "r0", "nSNP.mig", "nSNP.cons")
write.table(parameters, paste(directory, "/Output/parameters__proj___group_.csv", sep=""), sep=",", col.names=TRUE, append=FALSE, quote=FALSE, row.names=FALSE)
#clean up, remember that these are still available in parameters
remove(k.V, nSNP.V, miggy.V, LBhet.V, LBp.V, maxage.V, broodsize.V, maturity.V, years.V, r0.V, nSNP.mig.V, nSNP.cons.V)
#2/28/22 I am removing k.V from this so I can reference it in Stochastsic.R
replicates    = 1 #20 #5 #10
allee         = 0    #1=yes, 0=no
matemigs      = 0    #1=yes, 0=no
plotit        = 0    #1=yes, 0=no
plotit2       = 0    #1=yes, 0=no
mutate        = 0    #1=yes, 0=no   #average mammalian genome mutation rate is 2.2 x 10^-9 per base pair per year, https://doi.org/10.1073/pnas.022629899
#krats = 2844.77 MB = 2844770000 bp x 2.2*10-9  = 6.258494 === does this matter here???
#bannertailed 0.0081 mutants/generation/locus, in Busch, Waser, and DeWoody 2007 doi: 10.1111/j.1365-294X.2007.03283.x.
mu            = 0.001  #mutation rate
styr          = 100 #year to start pop decline
nwk           = 300 #pop size after decline -- probs makes sense to keep these even in vary decline years and decline rate. should end @ same pt for all pop sizes
drp           = 10  #number of years for drop from k to nwk
dur           = 40  #duration of small pop size before pop growth
edyr          = styr+drp #150 #year to end pop decline, first year at low pop size (nwk)
s             = 5000 #(k.V*5) #size of source pop
r             = 1
#run model iterating over parameters
theEND = NULL
repEND = NULL
finalPOP = NULL
for(r in 1:nrow(parameters)){
ALL = RunModel(parameters, r, directory, replicates, prj, grp)
FINAL = ALL[[1]]
REP = ALL[[2]]
#POP = ALL[[2]]
####REMOVED## POP = RunModel(parameters, r, directory, replicates)
####REMOVED## write.table(POP, paste(directory, "/Output/CoverPop", r, ".csv", sep=""), sep=",", col.names=TRUE, row.names=F)
#####REMOVED##write.table(POP, paste(directory, "/Output/CoverPop.txt", sep=""), sep="\t", col.names=TRUE, row.names=F)  #use this for a .txt file, good for in a text editor. ; "/t" for macs
theEND = rbind(theEND, FINAL)
repEND = rbind(repEND, REP)
#finalPOP = rbind(finalPOP, POP)
}
setwd("C:/Users/ginab/Box/New Computer/Auburn/Data/ComplexModel_ABM/ABM_sep2022")
directory = getwd()
outdir = paste(directory, "/Output/", sep = "")   #  outdir = paste("C:/Users/ginab/Box/New Computer/Auburn/Data/ComplexModel_ABM", "/Output_local/", sep = "")
source(paste(directory, "/Source/FunctionSourcer.R", sep = ''))
prj = "_proj_"
grp = "_group_"
#parameters
k.V           = 100 #1000 #c(1000, 5000, 500) #c(500, 1000, 5000, 10000)                #carrying capacity
nSNP.V        = 100 #1000  #scaleup                #number of SNPs simulated, used to track drift
miggy.V       = "b" #c(0,"a","b","c")  #"a"=one mig per gen, "b"=1xof50@175, "c"=3xpf25@175|201|225  #migration parameter type
LBhet.V       = 0.45 #c(0.45, 0.07) #c(0.1, 0.45, 0.8) #lowerbound limit for SOURCE POP  #c(0.4, 0.6) #c(0.8, 0.9)   #THINK ABOUT THE BEST WAY TO SET THIS UP -- either give the values for lower bound and then in RunModel, +1 for upper bound. or change the lower and upper depending on the run
LBp.V         = 0.07 #c(0.45, 0.07) #lowerbound limit for FOCAL POP
maxage.V      = 9 #c(15, 3) #9     #low ages dont work              #maximum age individuals can be; add one at first, so they will die at 4, start at -1
broodsize.V   = 2 #c(4, 6)  #2     #this is now the MAX brood size, aka max fecundity   #REMOVED##c(0:2)              #aka fecundity, remember that this is typically not constant in life; potentially Poisson distribution
maturity.V    = 1                   #age indv becomes reproductively mature
years.V       = 35 #350  #scaleup               #total run time; 200 year run following 50 year stabilization period
r0.V          = 1 #c(1, 0.5, 0.1)  #c(1, .8, 1.2) #0.1 #c(0.1, 0.2, 0.5)                 #per capita growth rate #0/1 is stable, <0/1 is decreasing, >0/1 is increasing - currently checking cuz r0+1 in log growth eq
nSNP.mig.V    = 10 #100                   #number of special alleles for migrants -- these are ADDITIONAL alleles, migrants = 1, orig pop = 0, this will be easier to track than a random value
nSNP.cons.V   = 0        #number of conserved alleles within species -- used to track mutation
#REMOVED##ratemort.V    = 1/(maxage.V*2) #note, I dont think this is used for anything anymore! ###0.2225 #??##(1/(maxage.V+2))      #proportion of adults that die each year --CHECK WITH JANNA WHERE THIS NUMBER CAME FROM; current value of .2225 is from Waser and Jones 1991
### when adding variables already marked out, don't forget to add 3 times below, on RunModel, and other functions that need the variable fed in
#potential migration rates: 1-5 indv, 5-10 indv, no migration
#generate list of parameter combinations
parameters = expand.grid(k.V, nSNP.V, miggy.V, LBhet.V, LBp.V, maxage.V, broodsize.V, maturity.V, years.V, r0.V, nSNP.mig.V, nSNP.cons.V)
colnames(parameters) = c("k", "nSNP", "miggy", "LBhet", "LBp", "maxage", "broodsize", "maturity", "years", "r0", "nSNP.mig", "nSNP.cons")
write.table(parameters, paste(directory, "/Output/parameters__proj___group_.csv", sep=""), sep=",", col.names=TRUE, append=FALSE, quote=FALSE, row.names=FALSE)
#clean up, remember that these are still available in parameters
remove(k.V, nSNP.V, miggy.V, LBhet.V, LBp.V, maxage.V, broodsize.V, maturity.V, years.V, r0.V, nSNP.mig.V, nSNP.cons.V)
#2/28/22 I am removing k.V from this so I can reference it in Stochastsic.R
replicates    = 1 #20 #5 #10
allee         = 0    #1=yes, 0=no
matemigs      = 0    #1=yes, 0=no
plotit        = 0    #1=yes, 0=no
plotit2       = 0    #1=yes, 0=no
mutate        = 0    #1=yes, 0=no   #average mammalian genome mutation rate is 2.2 x 10^-9 per base pair per year, https://doi.org/10.1073/pnas.022629899
#krats = 2844.77 MB = 2844770000 bp x 2.2*10-9  = 6.258494 === does this matter here???
#bannertailed 0.0081 mutants/generation/locus, in Busch, Waser, and DeWoody 2007 doi: 10.1111/j.1365-294X.2007.03283.x.
mu            = 0.001  #mutation rate
styr          = 100 #year to start pop decline
nwk           = 300 #pop size after decline -- probs makes sense to keep these even in vary decline years and decline rate. should end @ same pt for all pop sizes
drp           = 10  #number of years for drop from k to nwk
dur           = 40  #duration of small pop size before pop growth
edyr          = styr+drp #150 #year to end pop decline, first year at low pop size (nwk)
s             = 5000 #(k.V*5) #size of source pop
r             = 1
#run model iterating over parameters
theEND = NULL
repEND = NULL
finalPOP = NULL
for(r in 1:nrow(parameters)){
ALL = RunModel(parameters, r, directory, replicates, prj, grp)
FINAL = ALL[[1]]
REP = ALL[[2]]
#POP = ALL[[2]]
####REMOVED## POP = RunModel(parameters, r, directory, replicates)
####REMOVED## write.table(POP, paste(directory, "/Output/CoverPop", r, ".csv", sep=""), sep=",", col.names=TRUE, row.names=F)
#####REMOVED##write.table(POP, paste(directory, "/Output/CoverPop.txt", sep=""), sep="\t", col.names=TRUE, row.names=F)  #use this for a .txt file, good for in a text editor. ; "/t" for macs
theEND = rbind(theEND, FINAL)
repEND = rbind(repEND, REP)
#finalPOP = rbind(finalPOP, POP)
}
